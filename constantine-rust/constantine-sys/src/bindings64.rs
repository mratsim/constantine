/* automatically generated by rust-bindgen 0.71.1 */

pub type secret_word = usize;
pub type secret_bool = usize;
pub type byte = u8;
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_codec_scalar_status {
    cttCodecScalar_Success = 0,
    cttCodecScalar_Zero = 1,
    cttCodecScalar_ScalarLargerThanCurveOrder = 2,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_codec_ecc_status {
    cttCodecEcc_Success = 0,
    cttCodecEcc_InvalidEncoding = 1,
    cttCodecEcc_CoordinateGreaterThanOrEqualModulus = 2,
    cttCodecEcc_PointNotOnCurve = 3,
    cttCodecEcc_PointNotInSubgroup = 4,
    cttCodecEcc_PointAtInfinity = 5,
}
#[repr(C)]
#[derive(Debug)]
pub struct ctt_threadpool {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create a new threadpool that manages `num_threads` threads\n\n Initialize a threadpool that manages `num_threads` threads.\n\n A threadpool uses thread-local storage and (for external consumers)\n MUST be used from the thread that instantiated it.\n\n In particular, this means that:\n - runtime.LockOSThread() is needed from Go to avoid it allocating CGO calls to a new thread.\n - The threadpool cannot be ``Send`` in Rust or ``Clone`` (we can't deep-copy threads)\n\n 2 threadpools MUST NOT be instantiated at the same time from the same thread.\n\n Mixing with other libraries' threadpools and runtime\n will not impact correctness but may impact performance.\n"]
    pub fn ctt_threadpool_new(num_threads: ::core::ffi::c_int) -> *mut ctt_threadpool;
}
unsafe extern "C" {
    #[doc = " Wait until all pending tasks are processed and then shutdown the threadpool"]
    pub fn ctt_threadpool_shutdown(threadpool: *mut ctt_threadpool);
}
unsafe extern "C" {
    #[doc = " Query the number of threads available at the OS-level\n  to run computations.\n\n  This takes into account cores disabled at the OS-level, for example in a VM.\n  However this doesn't detect restrictions based on time quotas often used for Docker\n  or taskset / cpuset restrictions from cgroups.\n\n  For Simultaneous-Multithreading (SMT often call HyperThreading),\n  this returns the number of available logical cores."]
    pub fn ctt_cpu_get_num_threads_os() -> ::core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct ctt_sha256_context {
    pub message_schedule: [u32; 16usize],
    pub buf: [byte; 64usize],
    pub msgLen: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_sha256_context"][::core::mem::size_of::<ctt_sha256_context>() - 192usize];
    ["Alignment of ctt_sha256_context"][::core::mem::align_of::<ctt_sha256_context>() - 64usize];
    ["Offset of field: ctt_sha256_context::message_schedule"]
        [::core::mem::offset_of!(ctt_sha256_context, message_schedule) - 0usize];
    ["Offset of field: ctt_sha256_context::buf"]
        [::core::mem::offset_of!(ctt_sha256_context, buf) - 64usize];
    ["Offset of field: ctt_sha256_context::msgLen"]
        [::core::mem::offset_of!(ctt_sha256_context, msgLen) - 128usize];
};
impl Default for ctt_sha256_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Initialize or reinitialize a Sha256 context."]
    pub fn ctt_sha256_init(ctx: *mut ctt_sha256_context);
}
unsafe extern "C" {
    #[doc = " Append a message to a SHA256 context\n  for incremental SHA256 computation\n\n  Security note: the tail of your message might be stored\n  in an internal buffer.\n  if sensitive content is used, ensure that\n  `ctx.finish(...)` and `ctx.clear()` are called as soon as possible.\n  Additionally ensure that the message(s) passed were stored\n  in memory considered secure for your threat model.\n\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_update(
        ctx: *mut ctt_sha256_context,
        message: *const byte,
        message_len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Finalize a SHA256 computation and output the\n  message digest to the `digest` buffer.\n\n  Security note: this does not clear the internal buffer.\n  if sensitive content is used, use \"ctx.clear()\"\n  and also make sure that the message(s) passed were stored\n  in memory considered secure for your threat model.\n\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_finish(ctx: *mut ctt_sha256_context, digest: *mut byte);
}
unsafe extern "C" {
    #[doc = " Clear the context internal buffers\n  Security note:\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_clear(ctx: *mut ctt_sha256_context);
}
unsafe extern "C" {
    #[doc = " Compute the SHA-256 hash of message\n  and store the result in digest.\n  Optionally, clear the memory buffer used."]
    pub fn ctt_sha256_hash(
        digest: *mut byte,
        message: *const byte,
        message_len: usize,
        clear_memory: bool,
    );
}
unsafe extern "C" {
    pub fn ctt_csprng_sysrand(buffer: *mut ::core::ffi::c_void, len: usize) -> bool;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct big381 {
    pub limbs: [secret_word; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of big381"][::core::mem::size_of::<big381>() - 48usize];
    ["Alignment of big381"][::core::mem::align_of::<big381>() - 8usize];
    ["Offset of field: big381::limbs"][::core::mem::offset_of!(big381, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct big255 {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of big255"][::core::mem::size_of::<big255>() - 32usize];
    ["Alignment of big255"][::core::mem::align_of::<big255>() - 8usize];
    ["Offset of field: big255::limbs"][::core::mem::offset_of!(big255, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct big254 {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of big254"][::core::mem::size_of::<big254>() - 32usize];
    ["Alignment of big254"][::core::mem::align_of::<big254>() - 8usize];
    ["Offset of field: big254::limbs"][::core::mem::offset_of!(big254, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct big253 {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of big253"][::core::mem::size_of::<big253>() - 32usize];
    ["Alignment of big253"][::core::mem::align_of::<big253>() - 8usize];
    ["Offset of field: big253::limbs"][::core::mem::offset_of!(big253, limbs) - 0usize];
};
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big253_unmarshalBE(dst: *mut big253, src: *const byte, src_len: usize) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big253_marshalBE(dst: *mut byte, dst_len: usize, src: *const big253) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big254_unmarshalBE(dst: *mut big254, src: *const byte, src_len: usize) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big254_marshalBE(dst: *mut byte, dst_len: usize, src: *const big254) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big255_unmarshalBE(dst: *mut big255, src: *const byte, src_len: usize) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big255_marshalBE(dst: *mut byte, dst_len: usize, src: *const big255) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big381_unmarshalBE(dst: *mut big381, src: *const byte, src_len: usize) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_big381_marshalBE(dst: *mut byte, dst_len: usize, src: *const big381) -> bool;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_fr {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_fr"][::core::mem::size_of::<bls12_381_fr>() - 32usize];
    ["Alignment of bls12_381_fr"][::core::mem::align_of::<bls12_381_fr>() - 8usize];
    ["Offset of field: bls12_381_fr::limbs"][::core::mem::offset_of!(bls12_381_fr, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_fp {
    pub limbs: [secret_word; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_fp"][::core::mem::size_of::<bls12_381_fp>() - 48usize];
    ["Alignment of bls12_381_fp"][::core::mem::align_of::<bls12_381_fp>() - 8usize];
    ["Offset of field: bls12_381_fp::limbs"][::core::mem::offset_of!(bls12_381_fp, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_fp2 {
    pub c: [bls12_381_fp; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_fp2"][::core::mem::size_of::<bls12_381_fp2>() - 96usize];
    ["Alignment of bls12_381_fp2"][::core::mem::align_of::<bls12_381_fp2>() - 8usize];
    ["Offset of field: bls12_381_fp2::c"][::core::mem::offset_of!(bls12_381_fp2, c) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_g1_aff {
    pub x: bls12_381_fp,
    pub y: bls12_381_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_g1_aff"][::core::mem::size_of::<bls12_381_g1_aff>() - 96usize];
    ["Alignment of bls12_381_g1_aff"][::core::mem::align_of::<bls12_381_g1_aff>() - 8usize];
    ["Offset of field: bls12_381_g1_aff::x"][::core::mem::offset_of!(bls12_381_g1_aff, x) - 0usize];
    ["Offset of field: bls12_381_g1_aff::y"]
        [::core::mem::offset_of!(bls12_381_g1_aff, y) - 48usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_g1_jac {
    pub x: bls12_381_fp,
    pub y: bls12_381_fp,
    pub z: bls12_381_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_g1_jac"][::core::mem::size_of::<bls12_381_g1_jac>() - 144usize];
    ["Alignment of bls12_381_g1_jac"][::core::mem::align_of::<bls12_381_g1_jac>() - 8usize];
    ["Offset of field: bls12_381_g1_jac::x"][::core::mem::offset_of!(bls12_381_g1_jac, x) - 0usize];
    ["Offset of field: bls12_381_g1_jac::y"]
        [::core::mem::offset_of!(bls12_381_g1_jac, y) - 48usize];
    ["Offset of field: bls12_381_g1_jac::z"]
        [::core::mem::offset_of!(bls12_381_g1_jac, z) - 96usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_g1_prj {
    pub x: bls12_381_fp,
    pub y: bls12_381_fp,
    pub z: bls12_381_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_g1_prj"][::core::mem::size_of::<bls12_381_g1_prj>() - 144usize];
    ["Alignment of bls12_381_g1_prj"][::core::mem::align_of::<bls12_381_g1_prj>() - 8usize];
    ["Offset of field: bls12_381_g1_prj::x"][::core::mem::offset_of!(bls12_381_g1_prj, x) - 0usize];
    ["Offset of field: bls12_381_g1_prj::y"]
        [::core::mem::offset_of!(bls12_381_g1_prj, y) - 48usize];
    ["Offset of field: bls12_381_g1_prj::z"]
        [::core::mem::offset_of!(bls12_381_g1_prj, z) - 96usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_g2_aff {
    pub x: bls12_381_fp2,
    pub y: bls12_381_fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_g2_aff"][::core::mem::size_of::<bls12_381_g2_aff>() - 192usize];
    ["Alignment of bls12_381_g2_aff"][::core::mem::align_of::<bls12_381_g2_aff>() - 8usize];
    ["Offset of field: bls12_381_g2_aff::x"][::core::mem::offset_of!(bls12_381_g2_aff, x) - 0usize];
    ["Offset of field: bls12_381_g2_aff::y"]
        [::core::mem::offset_of!(bls12_381_g2_aff, y) - 96usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_g2_jac {
    pub x: bls12_381_fp2,
    pub y: bls12_381_fp2,
    pub z: bls12_381_fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_g2_jac"][::core::mem::size_of::<bls12_381_g2_jac>() - 288usize];
    ["Alignment of bls12_381_g2_jac"][::core::mem::align_of::<bls12_381_g2_jac>() - 8usize];
    ["Offset of field: bls12_381_g2_jac::x"][::core::mem::offset_of!(bls12_381_g2_jac, x) - 0usize];
    ["Offset of field: bls12_381_g2_jac::y"]
        [::core::mem::offset_of!(bls12_381_g2_jac, y) - 96usize];
    ["Offset of field: bls12_381_g2_jac::z"]
        [::core::mem::offset_of!(bls12_381_g2_jac, z) - 192usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bls12_381_g2_prj {
    pub x: bls12_381_fp2,
    pub y: bls12_381_fp2,
    pub z: bls12_381_fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bls12_381_g2_prj"][::core::mem::size_of::<bls12_381_g2_prj>() - 288usize];
    ["Alignment of bls12_381_g2_prj"][::core::mem::align_of::<bls12_381_g2_prj>() - 8usize];
    ["Offset of field: bls12_381_g2_prj::x"][::core::mem::offset_of!(bls12_381_g2_prj, x) - 0usize];
    ["Offset of field: bls12_381_g2_prj::y"]
        [::core::mem::offset_of!(bls12_381_g2_prj, y) - 96usize];
    ["Offset of field: bls12_381_g2_prj::z"]
        [::core::mem::offset_of!(bls12_381_g2_prj, z) - 192usize];
};
unsafe extern "C" {
    pub fn ctt_big255_from_bls12_381_fr(dst: *mut big255, src: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_from_big255(dst: *mut bls12_381_fr, src: *const big255);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fr_unmarshalBE(
        dst: *mut bls12_381_fr,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fr_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bls12_381_fr,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_is_eq(a: *const bls12_381_fr, b: *const bls12_381_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_is_zero(a: *const bls12_381_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_is_one(a: *const bls12_381_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_is_minus_one(a: *const bls12_381_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_set_zero(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_set_one(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_set_minus_one(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_neg(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_neg_in_place(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_sum(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_add_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_diff(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_sub_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_double(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_double_in_place(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_prod(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_mul_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_square(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_square_in_place(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_div2(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_inv(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_inv_in_place(a: *mut bls12_381_fr);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_ccopy(a: *mut bls12_381_fr, b: *const bls12_381_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_cswap(a: *mut bls12_381_fr, b: *mut bls12_381_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_cset_zero(a: *mut bls12_381_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_cset_one(a: *mut bls12_381_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_cneg_in_place(a: *mut bls12_381_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_cadd_in_place(
        a: *mut bls12_381_fr,
        b: *const bls12_381_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fr_csub_in_place(
        a: *mut bls12_381_fr,
        b: *const bls12_381_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_big381_from_bls12_381_fp(dst: *mut big381, src: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_from_big381(dst: *mut bls12_381_fp, src: *const big381);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fp_unmarshalBE(
        dst: *mut bls12_381_fp,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fp_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bls12_381_fp,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_is_eq(a: *const bls12_381_fp, b: *const bls12_381_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_is_zero(a: *const bls12_381_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_is_one(a: *const bls12_381_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_is_minus_one(a: *const bls12_381_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_set_zero(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_set_one(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_set_minus_one(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_neg(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_neg_in_place(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_sum(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_add_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_diff(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_sub_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_double(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_double_in_place(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_prod(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_mul_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_square(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_square_in_place(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_div2(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_inv(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_inv_in_place(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_ccopy(a: *mut bls12_381_fp, b: *const bls12_381_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_cswap(a: *mut bls12_381_fp, b: *mut bls12_381_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_cset_zero(a: *mut bls12_381_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_cset_one(a: *mut bls12_381_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_cneg_in_place(a: *mut bls12_381_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_cadd_in_place(
        a: *mut bls12_381_fp,
        b: *const bls12_381_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_csub_in_place(
        a: *mut bls12_381_fp,
        b: *const bls12_381_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_is_square(a: *const bls12_381_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_invsqrt(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_invsqrt_in_place(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_in_place(a: *mut bls12_381_fp);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_if_square_in_place(a: *mut bls12_381_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_invsqrt(
        sqrt: *mut bls12_381_fp,
        invsqrt: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_invsqrt_if_square(
        sqrt: *mut bls12_381_fp,
        invsqrt: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_ratio_if_square(
        r: *mut bls12_381_fp,
        u: *const bls12_381_fp,
        v: *const bls12_381_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_is_eq(a: *const bls12_381_fp2, b: *const bls12_381_fp2)
        -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_is_zero(a: *const bls12_381_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_is_one(a: *const bls12_381_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_is_minus_one(a: *const bls12_381_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_set_zero(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_set_one(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_set_minus_one(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_neg(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_sum(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_add_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_diff(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_sub_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_double(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_double_in_place(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_conj(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_conj_in_place(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_conjneg(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_conjneg_in_place(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_prod(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_mul_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_square(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_square_in_place(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_div2(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_inv(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_inv_in_place(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_ccopy(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_cset_zero(a: *mut bls12_381_fp2, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_cset_one(a: *mut bls12_381_fp2, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_cneg_in_place(a: *mut bls12_381_fp2, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_cadd_in_place(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_csub_in_place(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_is_square(a: *const bls12_381_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_sqrt_in_place(a: *mut bls12_381_fp2);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_fp2_sqrt_if_square_in_place(a: *mut bls12_381_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_eq(
        P: *const bls12_381_g1_aff,
        Q: *const bls12_381_g1_aff,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_neutral(P: *const bls12_381_g1_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_set_neutral(P: *mut bls12_381_g1_aff);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_ccopy(
        P: *mut bls12_381_g1_aff,
        Q: *const bls12_381_g1_aff,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_on_curve(
        x: *const bls12_381_fp,
        y: *const bls12_381_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_neg(P: *mut bls12_381_g1_aff, Q: *const bls12_381_g1_aff);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_neg_in_place(P: *mut bls12_381_g1_aff);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_is_eq(
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_is_neutral(P: *const bls12_381_g1_jac) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_set_neutral(P: *mut bls12_381_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_ccopy(
        P: *mut bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_neg(P: *mut bls12_381_g1_jac, Q: *const bls12_381_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_neg_in_place(P: *mut bls12_381_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_cneg_in_place(P: *mut bls12_381_g1_jac, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_sum(
        r: *mut bls12_381_g1_jac,
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_add_in_place(P: *mut bls12_381_g1_jac, Q: *const bls12_381_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_diff(
        r: *mut bls12_381_g1_jac,
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_double(r: *mut bls12_381_g1_jac, P: *const bls12_381_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_double_in_place(P: *mut bls12_381_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_affine(dst: *mut bls12_381_g1_aff, src: *const bls12_381_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_from_affine(
        dst: *mut bls12_381_g1_jac,
        src: *const bls12_381_g1_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_batch_affine(
        dst: *const bls12_381_g1_aff,
        src: *const bls12_381_g1_jac,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_big_coef(
        P: *mut bls12_381_g1_jac,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_fr_coef(
        P: *mut bls12_381_g1_jac,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g1_jac,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g1_jac,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g1_jac,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g1_jac,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_is_eq(
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_is_neutral(P: *const bls12_381_g1_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_set_neutral(P: *mut bls12_381_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_ccopy(
        P: *mut bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_neg(P: *mut bls12_381_g1_prj, Q: *const bls12_381_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_neg_in_place(P: *mut bls12_381_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_cneg_in_place(P: *mut bls12_381_g1_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_sum(
        r: *mut bls12_381_g1_prj,
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_add_in_place(P: *mut bls12_381_g1_prj, Q: *const bls12_381_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_diff(
        r: *mut bls12_381_g1_prj,
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_double(r: *mut bls12_381_g1_prj, P: *const bls12_381_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_double_in_place(P: *mut bls12_381_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_affine(dst: *mut bls12_381_g1_aff, src: *const bls12_381_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_from_affine(
        dst: *mut bls12_381_g1_prj,
        src: *const bls12_381_g1_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_batch_affine(
        dst: *const bls12_381_g1_aff,
        src: *const bls12_381_g1_prj,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_big_coef(
        P: *mut bls12_381_g1_prj,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_fr_coef(
        P: *mut bls12_381_g1_prj,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g1_prj,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g1_prj,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g1_prj,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g1_prj,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_eq(
        P: *const bls12_381_g2_aff,
        Q: *const bls12_381_g2_aff,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_neutral(P: *const bls12_381_g2_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_set_neutral(P: *mut bls12_381_g2_aff);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_ccopy(
        P: *mut bls12_381_g2_aff,
        Q: *const bls12_381_g2_aff,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_on_curve(
        x: *const bls12_381_fp2,
        y: *const bls12_381_fp2,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_neg(P: *mut bls12_381_g2_aff, Q: *const bls12_381_g2_aff);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_neg_in_place(P: *mut bls12_381_g2_aff);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_is_eq(
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_is_neutral(P: *const bls12_381_g2_jac) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_set_neutral(P: *mut bls12_381_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_ccopy(
        P: *mut bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_neg(P: *mut bls12_381_g2_jac, Q: *const bls12_381_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_neg_in_place(P: *mut bls12_381_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_cneg_in_place(P: *mut bls12_381_g2_jac, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_sum(
        r: *mut bls12_381_g2_jac,
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_add_in_place(P: *mut bls12_381_g2_jac, Q: *const bls12_381_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_diff(
        r: *mut bls12_381_g2_jac,
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_double(r: *mut bls12_381_g2_jac, P: *const bls12_381_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_double_in_place(P: *mut bls12_381_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_affine(dst: *mut bls12_381_g2_aff, src: *const bls12_381_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_from_affine(
        dst: *mut bls12_381_g2_jac,
        src: *const bls12_381_g2_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_batch_affine(
        dst: *const bls12_381_g2_aff,
        src: *const bls12_381_g2_jac,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_big_coef(
        P: *mut bls12_381_g2_jac,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_fr_coef(
        P: *mut bls12_381_g2_jac,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g2_jac,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g2_jac,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g2_jac,
        coefs: *const big255,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g2_jac,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_is_eq(
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_is_neutral(P: *const bls12_381_g2_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_set_neutral(P: *mut bls12_381_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_ccopy(
        P: *mut bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_neg(P: *mut bls12_381_g2_prj, Q: *const bls12_381_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_neg_in_place(P: *mut bls12_381_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_cneg_in_place(P: *mut bls12_381_g2_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_sum(
        r: *mut bls12_381_g2_prj,
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_add_in_place(P: *mut bls12_381_g2_prj, Q: *const bls12_381_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_diff(
        r: *mut bls12_381_g2_prj,
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_double(r: *mut bls12_381_g2_prj, P: *const bls12_381_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_double_in_place(P: *mut bls12_381_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_affine(dst: *mut bls12_381_g2_aff, src: *const bls12_381_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_from_affine(
        dst: *mut bls12_381_g2_prj,
        src: *const bls12_381_g2_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_batch_affine(
        dst: *const bls12_381_g2_aff,
        src: *const bls12_381_g2_prj,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_big_coef(
        P: *mut bls12_381_g2_prj,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_fr_coef(
        P: *mut bls12_381_g2_prj,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g2_prj,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g2_prj,
        scalar: *const bls12_381_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g2_prj,
        coefs: *const big255,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g2_prj,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_aff_sswu_sha256(
        r: *mut bls12_381_g1_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_sswu_sha256(
        r: *mut bls12_381_g1_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_sswu_sha256(
        r: *mut bls12_381_g1_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_aff_sswu_sha256(
        r: *mut bls12_381_g2_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_jac_sswu_sha256(
        r: *mut bls12_381_g2_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g2_prj_sswu_sha256(
        r: *mut bls12_381_g2_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_fr {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_fr"][::core::mem::size_of::<bn254_snarks_fr>() - 32usize];
    ["Alignment of bn254_snarks_fr"][::core::mem::align_of::<bn254_snarks_fr>() - 8usize];
    ["Offset of field: bn254_snarks_fr::limbs"]
        [::core::mem::offset_of!(bn254_snarks_fr, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_fp {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_fp"][::core::mem::size_of::<bn254_snarks_fp>() - 32usize];
    ["Alignment of bn254_snarks_fp"][::core::mem::align_of::<bn254_snarks_fp>() - 8usize];
    ["Offset of field: bn254_snarks_fp::limbs"]
        [::core::mem::offset_of!(bn254_snarks_fp, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_fp2 {
    pub c: [bn254_snarks_fp; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_fp2"][::core::mem::size_of::<bn254_snarks_fp2>() - 64usize];
    ["Alignment of bn254_snarks_fp2"][::core::mem::align_of::<bn254_snarks_fp2>() - 8usize];
    ["Offset of field: bn254_snarks_fp2::c"][::core::mem::offset_of!(bn254_snarks_fp2, c) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_g1_aff {
    pub x: bn254_snarks_fp,
    pub y: bn254_snarks_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_g1_aff"][::core::mem::size_of::<bn254_snarks_g1_aff>() - 64usize];
    ["Alignment of bn254_snarks_g1_aff"][::core::mem::align_of::<bn254_snarks_g1_aff>() - 8usize];
    ["Offset of field: bn254_snarks_g1_aff::x"]
        [::core::mem::offset_of!(bn254_snarks_g1_aff, x) - 0usize];
    ["Offset of field: bn254_snarks_g1_aff::y"]
        [::core::mem::offset_of!(bn254_snarks_g1_aff, y) - 32usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_g1_jac {
    pub x: bn254_snarks_fp,
    pub y: bn254_snarks_fp,
    pub z: bn254_snarks_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_g1_jac"][::core::mem::size_of::<bn254_snarks_g1_jac>() - 96usize];
    ["Alignment of bn254_snarks_g1_jac"][::core::mem::align_of::<bn254_snarks_g1_jac>() - 8usize];
    ["Offset of field: bn254_snarks_g1_jac::x"]
        [::core::mem::offset_of!(bn254_snarks_g1_jac, x) - 0usize];
    ["Offset of field: bn254_snarks_g1_jac::y"]
        [::core::mem::offset_of!(bn254_snarks_g1_jac, y) - 32usize];
    ["Offset of field: bn254_snarks_g1_jac::z"]
        [::core::mem::offset_of!(bn254_snarks_g1_jac, z) - 64usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_g1_prj {
    pub x: bn254_snarks_fp,
    pub y: bn254_snarks_fp,
    pub z: bn254_snarks_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_g1_prj"][::core::mem::size_of::<bn254_snarks_g1_prj>() - 96usize];
    ["Alignment of bn254_snarks_g1_prj"][::core::mem::align_of::<bn254_snarks_g1_prj>() - 8usize];
    ["Offset of field: bn254_snarks_g1_prj::x"]
        [::core::mem::offset_of!(bn254_snarks_g1_prj, x) - 0usize];
    ["Offset of field: bn254_snarks_g1_prj::y"]
        [::core::mem::offset_of!(bn254_snarks_g1_prj, y) - 32usize];
    ["Offset of field: bn254_snarks_g1_prj::z"]
        [::core::mem::offset_of!(bn254_snarks_g1_prj, z) - 64usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_g2_aff {
    pub x: bn254_snarks_fp2,
    pub y: bn254_snarks_fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_g2_aff"][::core::mem::size_of::<bn254_snarks_g2_aff>() - 128usize];
    ["Alignment of bn254_snarks_g2_aff"][::core::mem::align_of::<bn254_snarks_g2_aff>() - 8usize];
    ["Offset of field: bn254_snarks_g2_aff::x"]
        [::core::mem::offset_of!(bn254_snarks_g2_aff, x) - 0usize];
    ["Offset of field: bn254_snarks_g2_aff::y"]
        [::core::mem::offset_of!(bn254_snarks_g2_aff, y) - 64usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_g2_jac {
    pub x: bn254_snarks_fp2,
    pub y: bn254_snarks_fp2,
    pub z: bn254_snarks_fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_g2_jac"][::core::mem::size_of::<bn254_snarks_g2_jac>() - 192usize];
    ["Alignment of bn254_snarks_g2_jac"][::core::mem::align_of::<bn254_snarks_g2_jac>() - 8usize];
    ["Offset of field: bn254_snarks_g2_jac::x"]
        [::core::mem::offset_of!(bn254_snarks_g2_jac, x) - 0usize];
    ["Offset of field: bn254_snarks_g2_jac::y"]
        [::core::mem::offset_of!(bn254_snarks_g2_jac, y) - 64usize];
    ["Offset of field: bn254_snarks_g2_jac::z"]
        [::core::mem::offset_of!(bn254_snarks_g2_jac, z) - 128usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bn254_snarks_g2_prj {
    pub x: bn254_snarks_fp2,
    pub y: bn254_snarks_fp2,
    pub z: bn254_snarks_fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bn254_snarks_g2_prj"][::core::mem::size_of::<bn254_snarks_g2_prj>() - 192usize];
    ["Alignment of bn254_snarks_g2_prj"][::core::mem::align_of::<bn254_snarks_g2_prj>() - 8usize];
    ["Offset of field: bn254_snarks_g2_prj::x"]
        [::core::mem::offset_of!(bn254_snarks_g2_prj, x) - 0usize];
    ["Offset of field: bn254_snarks_g2_prj::y"]
        [::core::mem::offset_of!(bn254_snarks_g2_prj, y) - 64usize];
    ["Offset of field: bn254_snarks_g2_prj::z"]
        [::core::mem::offset_of!(bn254_snarks_g2_prj, z) - 128usize];
};
unsafe extern "C" {
    pub fn ctt_big254_from_bn254_snarks_fr(dst: *mut big254, src: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_from_big254(dst: *mut bn254_snarks_fr, src: *const big254);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fr_unmarshalBE(
        dst: *mut bn254_snarks_fr,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fr_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bn254_snarks_fr,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_is_eq(
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_is_zero(a: *const bn254_snarks_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_is_one(a: *const bn254_snarks_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_is_minus_one(a: *const bn254_snarks_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_set_zero(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_set_one(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_set_minus_one(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_neg(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_neg_in_place(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_sum(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_add_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_diff(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_sub_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_double(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_double_in_place(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_prod(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_mul_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_square(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_square_in_place(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_div2(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_inv(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_inv_in_place(a: *mut bn254_snarks_fr);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_ccopy(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_cswap(
        a: *mut bn254_snarks_fr,
        b: *mut bn254_snarks_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_cset_zero(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_cset_one(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_cneg_in_place(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_cadd_in_place(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fr_csub_in_place(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_big254_from_bn254_snarks_fp(dst: *mut big254, src: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_from_big254(dst: *mut bn254_snarks_fp, src: *const big254);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fp_unmarshalBE(
        dst: *mut bn254_snarks_fp,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fp_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bn254_snarks_fp,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_is_eq(
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_is_zero(a: *const bn254_snarks_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_is_one(a: *const bn254_snarks_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_is_minus_one(a: *const bn254_snarks_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_set_zero(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_set_one(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_set_minus_one(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_neg(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_neg_in_place(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_sum(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_add_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_diff(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_sub_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_double(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_double_in_place(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_prod(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_mul_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_square(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_square_in_place(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_div2(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_inv(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_inv_in_place(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_ccopy(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_cswap(
        a: *mut bn254_snarks_fp,
        b: *mut bn254_snarks_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_cset_zero(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_cset_one(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_cneg_in_place(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_cadd_in_place(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_csub_in_place(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_is_square(a: *const bn254_snarks_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_invsqrt(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_invsqrt_in_place(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_in_place(a: *mut bn254_snarks_fp);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_if_square_in_place(a: *mut bn254_snarks_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_invsqrt(
        sqrt: *mut bn254_snarks_fp,
        invsqrt: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_invsqrt_if_square(
        sqrt: *mut bn254_snarks_fp,
        invsqrt: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_ratio_if_square(
        r: *mut bn254_snarks_fp,
        u: *const bn254_snarks_fp,
        v: *const bn254_snarks_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_eq(
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_zero(a: *const bn254_snarks_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_one(a: *const bn254_snarks_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_minus_one(a: *const bn254_snarks_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_zero(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_one(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_minus_one(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_neg(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_sum(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_add_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_diff(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_sub_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_double(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_double_in_place(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_conj(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_conj_in_place(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_conjneg(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_conjneg_in_place(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_prod(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_mul_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_square(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_square_in_place(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_div2(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_inv(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_inv_in_place(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_ccopy(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_cset_zero(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_cset_one(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_cneg_in_place(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_cadd_in_place(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_csub_in_place(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_square(a: *const bn254_snarks_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_sqrt_in_place(a: *mut bn254_snarks_fp2);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_fp2_sqrt_if_square_in_place(a: *mut bn254_snarks_fp2) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_eq(
        P: *const bn254_snarks_g1_aff,
        Q: *const bn254_snarks_g1_aff,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_neutral(P: *const bn254_snarks_g1_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_set_neutral(P: *mut bn254_snarks_g1_aff);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_ccopy(
        P: *mut bn254_snarks_g1_aff,
        Q: *const bn254_snarks_g1_aff,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_on_curve(
        x: *const bn254_snarks_fp,
        y: *const bn254_snarks_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_neg(P: *mut bn254_snarks_g1_aff, Q: *const bn254_snarks_g1_aff);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_neg_in_place(P: *mut bn254_snarks_g1_aff);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_is_eq(
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_is_neutral(P: *const bn254_snarks_g1_jac) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_set_neutral(P: *mut bn254_snarks_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_ccopy(
        P: *mut bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_neg(P: *mut bn254_snarks_g1_jac, Q: *const bn254_snarks_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_neg_in_place(P: *mut bn254_snarks_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_cneg_in_place(P: *mut bn254_snarks_g1_jac, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_sum(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_add_in_place(
        P: *mut bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_diff(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_double(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_double_in_place(P: *mut bn254_snarks_g1_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_affine(
        dst: *mut bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_from_affine(
        dst: *mut bn254_snarks_g1_jac,
        src: *const bn254_snarks_g1_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_batch_affine(
        dst: *const bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_jac,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_big_coef(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g1_jac,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g1_jac,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_is_eq(
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_is_neutral(P: *const bn254_snarks_g1_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_set_neutral(P: *mut bn254_snarks_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_ccopy(
        P: *mut bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_neg(P: *mut bn254_snarks_g1_prj, Q: *const bn254_snarks_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_neg_in_place(P: *mut bn254_snarks_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_cneg_in_place(P: *mut bn254_snarks_g1_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_sum(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_add_in_place(
        P: *mut bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_diff(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_double(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_double_in_place(P: *mut bn254_snarks_g1_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_affine(
        dst: *mut bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_from_affine(
        dst: *mut bn254_snarks_g1_prj,
        src: *const bn254_snarks_g1_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_batch_affine(
        dst: *const bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_prj,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_big_coef(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g1_prj,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g1_prj,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_eq(
        P: *const bn254_snarks_g2_aff,
        Q: *const bn254_snarks_g2_aff,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_neutral(P: *const bn254_snarks_g2_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_set_neutral(P: *mut bn254_snarks_g2_aff);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_ccopy(
        P: *mut bn254_snarks_g2_aff,
        Q: *const bn254_snarks_g2_aff,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_on_curve(
        x: *const bn254_snarks_fp2,
        y: *const bn254_snarks_fp2,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_neg(P: *mut bn254_snarks_g2_aff, Q: *const bn254_snarks_g2_aff);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_neg_in_place(P: *mut bn254_snarks_g2_aff);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_is_eq(
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_is_neutral(P: *const bn254_snarks_g2_jac) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_set_neutral(P: *mut bn254_snarks_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_ccopy(
        P: *mut bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_neg(P: *mut bn254_snarks_g2_jac, Q: *const bn254_snarks_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_neg_in_place(P: *mut bn254_snarks_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_cneg_in_place(P: *mut bn254_snarks_g2_jac, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_sum(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_add_in_place(
        P: *mut bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_diff(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_double(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_double_in_place(P: *mut bn254_snarks_g2_jac);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_affine(
        dst: *mut bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_from_affine(
        dst: *mut bn254_snarks_g2_jac,
        src: *const bn254_snarks_g2_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_batch_affine(
        dst: *const bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_jac,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_big_coef(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g2_jac,
        coefs: *const big254,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g2_jac,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_is_eq(
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_is_neutral(P: *const bn254_snarks_g2_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_set_neutral(P: *mut bn254_snarks_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_ccopy(
        P: *mut bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_neg(P: *mut bn254_snarks_g2_prj, Q: *const bn254_snarks_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_neg_in_place(P: *mut bn254_snarks_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_cneg_in_place(P: *mut bn254_snarks_g2_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_sum(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_add_in_place(
        P: *mut bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_diff(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_double(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_double_in_place(P: *mut bn254_snarks_g2_prj);
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_affine(
        dst: *mut bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_from_affine(
        dst: *mut bn254_snarks_g2_prj,
        src: *const bn254_snarks_g2_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_batch_affine(
        dst: *const bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_prj,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_big_coef(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const big254,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const bn254_snarks_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g2_prj,
        coefs: *const big254,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g2_prj,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_svdw_sha256(
        r: *mut bn254_snarks_g1_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_svdw_sha256(
        r: *mut bn254_snarks_g1_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_svdw_sha256(
        r: *mut bn254_snarks_g1_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_svdw_sha256(
        r: *mut bn254_snarks_g2_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_svdw_sha256(
        r: *mut bn254_snarks_g2_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_svdw_sha256(
        r: *mut bn254_snarks_g2_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pallas_fr {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pallas_fr"][::core::mem::size_of::<pallas_fr>() - 32usize];
    ["Alignment of pallas_fr"][::core::mem::align_of::<pallas_fr>() - 8usize];
    ["Offset of field: pallas_fr::limbs"][::core::mem::offset_of!(pallas_fr, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pallas_fp {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pallas_fp"][::core::mem::size_of::<pallas_fp>() - 32usize];
    ["Alignment of pallas_fp"][::core::mem::align_of::<pallas_fp>() - 8usize];
    ["Offset of field: pallas_fp::limbs"][::core::mem::offset_of!(pallas_fp, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pallas_ec_aff {
    pub x: pallas_fp,
    pub y: pallas_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pallas_ec_aff"][::core::mem::size_of::<pallas_ec_aff>() - 64usize];
    ["Alignment of pallas_ec_aff"][::core::mem::align_of::<pallas_ec_aff>() - 8usize];
    ["Offset of field: pallas_ec_aff::x"][::core::mem::offset_of!(pallas_ec_aff, x) - 0usize];
    ["Offset of field: pallas_ec_aff::y"][::core::mem::offset_of!(pallas_ec_aff, y) - 32usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pallas_ec_jac {
    pub x: pallas_fp,
    pub y: pallas_fp,
    pub z: pallas_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pallas_ec_jac"][::core::mem::size_of::<pallas_ec_jac>() - 96usize];
    ["Alignment of pallas_ec_jac"][::core::mem::align_of::<pallas_ec_jac>() - 8usize];
    ["Offset of field: pallas_ec_jac::x"][::core::mem::offset_of!(pallas_ec_jac, x) - 0usize];
    ["Offset of field: pallas_ec_jac::y"][::core::mem::offset_of!(pallas_ec_jac, y) - 32usize];
    ["Offset of field: pallas_ec_jac::z"][::core::mem::offset_of!(pallas_ec_jac, z) - 64usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pallas_ec_prj {
    pub x: pallas_fp,
    pub y: pallas_fp,
    pub z: pallas_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pallas_ec_prj"][::core::mem::size_of::<pallas_ec_prj>() - 96usize];
    ["Alignment of pallas_ec_prj"][::core::mem::align_of::<pallas_ec_prj>() - 8usize];
    ["Offset of field: pallas_ec_prj::x"][::core::mem::offset_of!(pallas_ec_prj, x) - 0usize];
    ["Offset of field: pallas_ec_prj::y"][::core::mem::offset_of!(pallas_ec_prj, y) - 32usize];
    ["Offset of field: pallas_ec_prj::z"][::core::mem::offset_of!(pallas_ec_prj, z) - 64usize];
};
unsafe extern "C" {
    pub fn ctt_big255_from_pallas_fr(dst: *mut big255, src: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_from_big255(dst: *mut pallas_fr, src: *const big255);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_pallas_fr_unmarshalBE(dst: *mut pallas_fr, src: *const byte, src_len: usize)
        -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_pallas_fr_marshalBE(dst: *mut byte, dst_len: usize, src: *const pallas_fr) -> bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_is_eq(a: *const pallas_fr, b: *const pallas_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_is_zero(a: *const pallas_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_is_one(a: *const pallas_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_is_minus_one(a: *const pallas_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_set_zero(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_set_one(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_set_minus_one(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_neg(r: *mut pallas_fr, a: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_neg_in_place(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_sum(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_add_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_diff(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_sub_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_double(r: *mut pallas_fr, a: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_double_in_place(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_prod(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_mul_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_square(r: *mut pallas_fr, a: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_square_in_place(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_div2(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_inv(r: *mut pallas_fr, a: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_inv_in_place(a: *mut pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_ccopy(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_cswap(a: *mut pallas_fr, b: *mut pallas_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_cset_zero(a: *mut pallas_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_cset_one(a: *mut pallas_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_cneg_in_place(a: *mut pallas_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_cadd_in_place(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fr_csub_in_place(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_big255_from_pallas_fp(dst: *mut big255, src: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_from_big255(dst: *mut pallas_fp, src: *const big255);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_pallas_fp_unmarshalBE(dst: *mut pallas_fp, src: *const byte, src_len: usize)
        -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_pallas_fp_marshalBE(dst: *mut byte, dst_len: usize, src: *const pallas_fp) -> bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_is_eq(a: *const pallas_fp, b: *const pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_is_zero(a: *const pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_is_one(a: *const pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_is_minus_one(a: *const pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_set_zero(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_set_one(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_set_minus_one(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_neg(r: *mut pallas_fp, a: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_neg_in_place(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_sum(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_add_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_diff(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_sub_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_double(r: *mut pallas_fp, a: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_double_in_place(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_prod(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_mul_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_square(r: *mut pallas_fp, a: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_square_in_place(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_div2(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_inv(r: *mut pallas_fp, a: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_inv_in_place(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_ccopy(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_cswap(a: *mut pallas_fp, b: *mut pallas_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_cset_zero(a: *mut pallas_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_cset_one(a: *mut pallas_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_cneg_in_place(a: *mut pallas_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_cadd_in_place(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_csub_in_place(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_is_square(a: *const pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_invsqrt(r: *mut pallas_fp, a: *const pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_invsqrt_in_place(r: *mut pallas_fp, a: *const pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_sqrt_in_place(a: *mut pallas_fp);
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_sqrt_if_square_in_place(a: *mut pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_sqrt_invsqrt(
        sqrt: *mut pallas_fp,
        invsqrt: *mut pallas_fp,
        a: *const pallas_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_sqrt_invsqrt_if_square(
        sqrt: *mut pallas_fp,
        invsqrt: *mut pallas_fp,
        a: *const pallas_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_fp_sqrt_ratio_if_square(
        r: *mut pallas_fp,
        u: *const pallas_fp,
        v: *const pallas_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_aff_is_eq(P: *const pallas_ec_aff, Q: *const pallas_ec_aff)
        -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_aff_is_neutral(P: *const pallas_ec_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_aff_set_neutral(P: *mut pallas_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_aff_ccopy(
        P: *mut pallas_ec_aff,
        Q: *const pallas_ec_aff,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_aff_is_on_curve(x: *const pallas_fp, y: *const pallas_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_aff_neg(P: *mut pallas_ec_aff, Q: *const pallas_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_aff_neg_in_place(P: *mut pallas_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_is_eq(P: *const pallas_ec_jac, Q: *const pallas_ec_jac)
        -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_is_neutral(P: *const pallas_ec_jac) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_set_neutral(P: *mut pallas_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_ccopy(
        P: *mut pallas_ec_jac,
        Q: *const pallas_ec_jac,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_neg(P: *mut pallas_ec_jac, Q: *const pallas_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_neg_in_place(P: *mut pallas_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_cneg_in_place(P: *mut pallas_ec_jac, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_sum(
        r: *mut pallas_ec_jac,
        P: *const pallas_ec_jac,
        Q: *const pallas_ec_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_add_in_place(P: *mut pallas_ec_jac, Q: *const pallas_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_diff(
        r: *mut pallas_ec_jac,
        P: *const pallas_ec_jac,
        Q: *const pallas_ec_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_double(r: *mut pallas_ec_jac, P: *const pallas_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_double_in_place(P: *mut pallas_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_affine(dst: *mut pallas_ec_aff, src: *const pallas_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_from_affine(dst: *mut pallas_ec_jac, src: *const pallas_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_batch_affine(
        dst: *const pallas_ec_aff,
        src: *const pallas_ec_jac,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_big_coef(P: *mut pallas_ec_jac, scalar: *const big255);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_fr_coef(P: *mut pallas_ec_jac, scalar: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_big_coef_vartime(
        P: *mut pallas_ec_jac,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_fr_coef_vartime(
        P: *mut pallas_ec_jac,
        scalar: *const pallas_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut pallas_ec_jac,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut pallas_ec_jac,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_is_eq(P: *const pallas_ec_prj, Q: *const pallas_ec_prj)
        -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_is_neutral(P: *const pallas_ec_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_set_neutral(P: *mut pallas_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_ccopy(
        P: *mut pallas_ec_prj,
        Q: *const pallas_ec_prj,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_neg(P: *mut pallas_ec_prj, Q: *const pallas_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_neg_in_place(P: *mut pallas_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_cneg_in_place(P: *mut pallas_ec_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_sum(
        r: *mut pallas_ec_prj,
        P: *const pallas_ec_prj,
        Q: *const pallas_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_add_in_place(P: *mut pallas_ec_prj, Q: *const pallas_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_diff(
        r: *mut pallas_ec_prj,
        P: *const pallas_ec_prj,
        Q: *const pallas_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_double(r: *mut pallas_ec_prj, P: *const pallas_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_double_in_place(P: *mut pallas_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_affine(dst: *mut pallas_ec_aff, src: *const pallas_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_from_affine(dst: *mut pallas_ec_prj, src: *const pallas_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_batch_affine(
        dst: *const pallas_ec_aff,
        src: *const pallas_ec_prj,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_big_coef(P: *mut pallas_ec_prj, scalar: *const big255);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_fr_coef(P: *mut pallas_ec_prj, scalar: *const pallas_fr);
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_big_coef_vartime(
        P: *mut pallas_ec_prj,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_fr_coef_vartime(
        P: *mut pallas_ec_prj,
        scalar: *const pallas_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut pallas_ec_prj,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut pallas_ec_prj,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vesta_fr {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vesta_fr"][::core::mem::size_of::<vesta_fr>() - 32usize];
    ["Alignment of vesta_fr"][::core::mem::align_of::<vesta_fr>() - 8usize];
    ["Offset of field: vesta_fr::limbs"][::core::mem::offset_of!(vesta_fr, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vesta_fp {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vesta_fp"][::core::mem::size_of::<vesta_fp>() - 32usize];
    ["Alignment of vesta_fp"][::core::mem::align_of::<vesta_fp>() - 8usize];
    ["Offset of field: vesta_fp::limbs"][::core::mem::offset_of!(vesta_fp, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vesta_ec_aff {
    pub x: vesta_fp,
    pub y: vesta_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vesta_ec_aff"][::core::mem::size_of::<vesta_ec_aff>() - 64usize];
    ["Alignment of vesta_ec_aff"][::core::mem::align_of::<vesta_ec_aff>() - 8usize];
    ["Offset of field: vesta_ec_aff::x"][::core::mem::offset_of!(vesta_ec_aff, x) - 0usize];
    ["Offset of field: vesta_ec_aff::y"][::core::mem::offset_of!(vesta_ec_aff, y) - 32usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vesta_ec_jac {
    pub x: vesta_fp,
    pub y: vesta_fp,
    pub z: vesta_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vesta_ec_jac"][::core::mem::size_of::<vesta_ec_jac>() - 96usize];
    ["Alignment of vesta_ec_jac"][::core::mem::align_of::<vesta_ec_jac>() - 8usize];
    ["Offset of field: vesta_ec_jac::x"][::core::mem::offset_of!(vesta_ec_jac, x) - 0usize];
    ["Offset of field: vesta_ec_jac::y"][::core::mem::offset_of!(vesta_ec_jac, y) - 32usize];
    ["Offset of field: vesta_ec_jac::z"][::core::mem::offset_of!(vesta_ec_jac, z) - 64usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vesta_ec_prj {
    pub x: vesta_fp,
    pub y: vesta_fp,
    pub z: vesta_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vesta_ec_prj"][::core::mem::size_of::<vesta_ec_prj>() - 96usize];
    ["Alignment of vesta_ec_prj"][::core::mem::align_of::<vesta_ec_prj>() - 8usize];
    ["Offset of field: vesta_ec_prj::x"][::core::mem::offset_of!(vesta_ec_prj, x) - 0usize];
    ["Offset of field: vesta_ec_prj::y"][::core::mem::offset_of!(vesta_ec_prj, y) - 32usize];
    ["Offset of field: vesta_ec_prj::z"][::core::mem::offset_of!(vesta_ec_prj, z) - 64usize];
};
unsafe extern "C" {
    pub fn ctt_big255_from_vesta_fr(dst: *mut big255, src: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_from_big255(dst: *mut vesta_fr, src: *const big255);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_vesta_fr_unmarshalBE(dst: *mut vesta_fr, src: *const byte, src_len: usize) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_vesta_fr_marshalBE(dst: *mut byte, dst_len: usize, src: *const vesta_fr) -> bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_is_eq(a: *const vesta_fr, b: *const vesta_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_is_zero(a: *const vesta_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_is_one(a: *const vesta_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_is_minus_one(a: *const vesta_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_set_zero(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_set_one(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_set_minus_one(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_neg(r: *mut vesta_fr, a: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_neg_in_place(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_sum(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_add_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_diff(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_sub_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_double(r: *mut vesta_fr, a: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_double_in_place(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_prod(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_mul_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_square(r: *mut vesta_fr, a: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_square_in_place(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_div2(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_inv(r: *mut vesta_fr, a: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_inv_in_place(a: *mut vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_ccopy(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_cswap(a: *mut vesta_fr, b: *mut vesta_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_cset_zero(a: *mut vesta_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_cset_one(a: *mut vesta_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_cneg_in_place(a: *mut vesta_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_cadd_in_place(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fr_csub_in_place(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_big255_from_vesta_fp(dst: *mut big255, src: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_from_big255(dst: *mut vesta_fp, src: *const big255);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_vesta_fp_unmarshalBE(dst: *mut vesta_fp, src: *const byte, src_len: usize) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_vesta_fp_marshalBE(dst: *mut byte, dst_len: usize, src: *const vesta_fp) -> bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_is_eq(a: *const vesta_fp, b: *const vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_is_zero(a: *const vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_is_one(a: *const vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_is_minus_one(a: *const vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_set_zero(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_set_one(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_set_minus_one(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_neg(r: *mut vesta_fp, a: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_neg_in_place(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_sum(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_add_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_diff(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_sub_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_double(r: *mut vesta_fp, a: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_double_in_place(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_prod(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_mul_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_square(r: *mut vesta_fp, a: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_square_in_place(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_div2(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_inv(r: *mut vesta_fp, a: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_inv_in_place(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_ccopy(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_cswap(a: *mut vesta_fp, b: *mut vesta_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_cset_zero(a: *mut vesta_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_cset_one(a: *mut vesta_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_cneg_in_place(a: *mut vesta_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_cadd_in_place(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_csub_in_place(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_is_square(a: *const vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_invsqrt(r: *mut vesta_fp, a: *const vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_invsqrt_in_place(r: *mut vesta_fp, a: *const vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_sqrt_in_place(a: *mut vesta_fp);
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_sqrt_if_square_in_place(a: *mut vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_sqrt_invsqrt(
        sqrt: *mut vesta_fp,
        invsqrt: *mut vesta_fp,
        a: *const vesta_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_sqrt_invsqrt_if_square(
        sqrt: *mut vesta_fp,
        invsqrt: *mut vesta_fp,
        a: *const vesta_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_fp_sqrt_ratio_if_square(
        r: *mut vesta_fp,
        u: *const vesta_fp,
        v: *const vesta_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_aff_is_eq(P: *const vesta_ec_aff, Q: *const vesta_ec_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_aff_is_neutral(P: *const vesta_ec_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_aff_set_neutral(P: *mut vesta_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_aff_ccopy(P: *mut vesta_ec_aff, Q: *const vesta_ec_aff, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_aff_is_on_curve(x: *const vesta_fp, y: *const vesta_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_aff_neg(P: *mut vesta_ec_aff, Q: *const vesta_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_aff_neg_in_place(P: *mut vesta_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_is_eq(P: *const vesta_ec_jac, Q: *const vesta_ec_jac) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_is_neutral(P: *const vesta_ec_jac) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_set_neutral(P: *mut vesta_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_ccopy(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_neg(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_neg_in_place(P: *mut vesta_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_cneg_in_place(P: *mut vesta_ec_jac, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_sum(
        r: *mut vesta_ec_jac,
        P: *const vesta_ec_jac,
        Q: *const vesta_ec_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_add_in_place(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_diff(
        r: *mut vesta_ec_jac,
        P: *const vesta_ec_jac,
        Q: *const vesta_ec_jac,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_double(r: *mut vesta_ec_jac, P: *const vesta_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_double_in_place(P: *mut vesta_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_affine(dst: *mut vesta_ec_aff, src: *const vesta_ec_jac);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_from_affine(dst: *mut vesta_ec_jac, src: *const vesta_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_batch_affine(
        dst: *const vesta_ec_aff,
        src: *const vesta_ec_jac,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_big_coef(P: *mut vesta_ec_jac, scalar: *const big255);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_fr_coef(P: *mut vesta_ec_jac, scalar: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_big_coef_vartime(
        P: *mut vesta_ec_jac,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_fr_coef_vartime(
        P: *mut vesta_ec_jac,
        scalar: *const vesta_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut vesta_ec_jac,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut vesta_ec_jac,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_is_eq(P: *const vesta_ec_prj, Q: *const vesta_ec_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_is_neutral(P: *const vesta_ec_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_set_neutral(P: *mut vesta_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_ccopy(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_neg(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_neg_in_place(P: *mut vesta_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_cneg_in_place(P: *mut vesta_ec_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_sum(
        r: *mut vesta_ec_prj,
        P: *const vesta_ec_prj,
        Q: *const vesta_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_add_in_place(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_diff(
        r: *mut vesta_ec_prj,
        P: *const vesta_ec_prj,
        Q: *const vesta_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_double(r: *mut vesta_ec_prj, P: *const vesta_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_double_in_place(P: *mut vesta_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_affine(dst: *mut vesta_ec_aff, src: *const vesta_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_from_affine(dst: *mut vesta_ec_prj, src: *const vesta_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_batch_affine(
        dst: *const vesta_ec_aff,
        src: *const vesta_ec_prj,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_big_coef(P: *mut vesta_ec_prj, scalar: *const big255);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_fr_coef(P: *mut vesta_ec_prj, scalar: *const vesta_fr);
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_big_coef_vartime(
        P: *mut vesta_ec_prj,
        scalar: *const big255,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_fr_coef_vartime(
        P: *mut vesta_ec_prj,
        scalar: *const vesta_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut vesta_ec_prj,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut vesta_ec_prj,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Validate a scalar\n  Regarding timing attacks, this will leak information\n  if the scalar is 0 or larger than the curve order."]
    pub fn ctt_bls12_381_validate_scalar(scalar: *const big255) -> ctt_codec_scalar_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Validate a G1 point\n  This is an expensive operation that can be cached"]
    pub fn ctt_bls12_381_validate_g1(point: *const bls12_381_g1_aff) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Validate a G2 point\n  This is an expensive operation that can be cached"]
    pub fn ctt_bls12_381_validate_g2(point: *const bls12_381_g2_aff) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Serialize a scalar\n  Returns cttCodecScalar_Success if successful"]
    pub fn ctt_bls12_381_serialize_scalar(
        dst: *mut byte,
        scalar: *const big255,
    ) -> ctt_codec_scalar_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a scalar\n  Also validates the scalar range\n\n  This is protected against side-channel unless the scalar is invalid.\n  In that case it will leak whether it's all zeros or larger than the curve order.\n\n  This special-cases (and leaks) 0 scalar as this is a special-case in most protocols\n  or completely invalid (for secret keys)."]
    pub fn ctt_bls12_381_deserialize_scalar(
        dst: *mut big255,
        src: *const byte,
    ) -> ctt_codec_scalar_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Serialize a BLS12-381 G1 point in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_bls12_381_serialize_g1_compressed(
        dst: *mut byte,
        src: *const bls12_381_g1_aff,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G1 point in compressed (Zcash) format.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks."]
    pub fn ctt_bls12_381_deserialize_g1_compressed_unchecked(
        dst: *mut bls12_381_g1_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G1 point in compressed (Zcash) format\n  This also validates the G1 point"]
    pub fn ctt_bls12_381_deserialize_g1_compressed(
        dst: *mut bls12_381_g1_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Serialize a BLS12-381 G2 point in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_bls12_381_serialize_g2_compressed(
        dst: *mut byte,
        src: *const bls12_381_g2_aff,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G2 point in compressed (Zcash) format.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks."]
    pub fn ctt_bls12_381_deserialize_g2_compressed_unchecked(
        dst: *mut bls12_381_g2_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G2 point in compressed (Zcash) format\n  This also validates the G2 point"]
    pub fn ctt_bls12_381_deserialize_g2_compressed(
        dst: *mut bls12_381_g2_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct banderwagon_fr {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of banderwagon_fr"][::core::mem::size_of::<banderwagon_fr>() - 32usize];
    ["Alignment of banderwagon_fr"][::core::mem::align_of::<banderwagon_fr>() - 8usize];
    ["Offset of field: banderwagon_fr::limbs"]
        [::core::mem::offset_of!(banderwagon_fr, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct banderwagon_fp {
    pub limbs: [secret_word; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of banderwagon_fp"][::core::mem::size_of::<banderwagon_fp>() - 32usize];
    ["Alignment of banderwagon_fp"][::core::mem::align_of::<banderwagon_fp>() - 8usize];
    ["Offset of field: banderwagon_fp::limbs"]
        [::core::mem::offset_of!(banderwagon_fp, limbs) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct banderwagon_ec_aff {
    pub x: banderwagon_fp,
    pub y: banderwagon_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of banderwagon_ec_aff"][::core::mem::size_of::<banderwagon_ec_aff>() - 64usize];
    ["Alignment of banderwagon_ec_aff"][::core::mem::align_of::<banderwagon_ec_aff>() - 8usize];
    ["Offset of field: banderwagon_ec_aff::x"]
        [::core::mem::offset_of!(banderwagon_ec_aff, x) - 0usize];
    ["Offset of field: banderwagon_ec_aff::y"]
        [::core::mem::offset_of!(banderwagon_ec_aff, y) - 32usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct banderwagon_ec_jac {
    pub x: banderwagon_fp,
    pub y: banderwagon_fp,
    pub z: banderwagon_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of banderwagon_ec_jac"][::core::mem::size_of::<banderwagon_ec_jac>() - 96usize];
    ["Alignment of banderwagon_ec_jac"][::core::mem::align_of::<banderwagon_ec_jac>() - 8usize];
    ["Offset of field: banderwagon_ec_jac::x"]
        [::core::mem::offset_of!(banderwagon_ec_jac, x) - 0usize];
    ["Offset of field: banderwagon_ec_jac::y"]
        [::core::mem::offset_of!(banderwagon_ec_jac, y) - 32usize];
    ["Offset of field: banderwagon_ec_jac::z"]
        [::core::mem::offset_of!(banderwagon_ec_jac, z) - 64usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct banderwagon_ec_prj {
    pub x: banderwagon_fp,
    pub y: banderwagon_fp,
    pub z: banderwagon_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of banderwagon_ec_prj"][::core::mem::size_of::<banderwagon_ec_prj>() - 96usize];
    ["Alignment of banderwagon_ec_prj"][::core::mem::align_of::<banderwagon_ec_prj>() - 8usize];
    ["Offset of field: banderwagon_ec_prj::x"]
        [::core::mem::offset_of!(banderwagon_ec_prj, x) - 0usize];
    ["Offset of field: banderwagon_ec_prj::y"]
        [::core::mem::offset_of!(banderwagon_ec_prj, y) - 32usize];
    ["Offset of field: banderwagon_ec_prj::z"]
        [::core::mem::offset_of!(banderwagon_ec_prj, z) - 64usize];
};
unsafe extern "C" {
    pub fn ctt_big253_from_banderwagon_fr(dst: *mut big253, src: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_from_big253(dst: *mut banderwagon_fr, src: *const big253);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_banderwagon_fr_unmarshalBE(
        dst: *mut banderwagon_fr,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_banderwagon_fr_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const banderwagon_fr,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_is_eq(
        a: *const banderwagon_fr,
        b: *const banderwagon_fr,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_is_zero(a: *const banderwagon_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_is_one(a: *const banderwagon_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_is_minus_one(a: *const banderwagon_fr) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_set_zero(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_set_one(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_set_minus_one(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_neg(r: *mut banderwagon_fr, a: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_neg_in_place(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_sum(
        r: *mut banderwagon_fr,
        a: *const banderwagon_fr,
        b: *const banderwagon_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_add_in_place(a: *mut banderwagon_fr, b: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_diff(
        r: *mut banderwagon_fr,
        a: *const banderwagon_fr,
        b: *const banderwagon_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_sub_in_place(a: *mut banderwagon_fr, b: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_double(r: *mut banderwagon_fr, a: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_double_in_place(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_prod(
        r: *mut banderwagon_fr,
        a: *const banderwagon_fr,
        b: *const banderwagon_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_mul_in_place(a: *mut banderwagon_fr, b: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_square(r: *mut banderwagon_fr, a: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_square_in_place(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_div2(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_inv(r: *mut banderwagon_fr, a: *const banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_inv_in_place(a: *mut banderwagon_fr);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_ccopy(
        a: *mut banderwagon_fr,
        b: *const banderwagon_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_cswap(
        a: *mut banderwagon_fr,
        b: *mut banderwagon_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_cset_zero(a: *mut banderwagon_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_cset_one(a: *mut banderwagon_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_cneg_in_place(a: *mut banderwagon_fr, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_cadd_in_place(
        a: *mut banderwagon_fr,
        b: *const banderwagon_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fr_csub_in_place(
        a: *mut banderwagon_fr,
        b: *const banderwagon_fr,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_big255_from_banderwagon_fp(dst: *mut big255, src: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_from_big255(dst: *mut banderwagon_fp, src: *const big255);
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_banderwagon_fp_unmarshalBE(
        dst: *mut banderwagon_fp,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_banderwagon_fp_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const banderwagon_fp,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_is_eq(
        a: *const banderwagon_fp,
        b: *const banderwagon_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_is_zero(a: *const banderwagon_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_is_one(a: *const banderwagon_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_is_minus_one(a: *const banderwagon_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_set_zero(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_set_one(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_set_minus_one(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_neg(r: *mut banderwagon_fp, a: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_neg_in_place(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_sum(
        r: *mut banderwagon_fp,
        a: *const banderwagon_fp,
        b: *const banderwagon_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_add_in_place(a: *mut banderwagon_fp, b: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_diff(
        r: *mut banderwagon_fp,
        a: *const banderwagon_fp,
        b: *const banderwagon_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_sub_in_place(a: *mut banderwagon_fp, b: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_double(r: *mut banderwagon_fp, a: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_double_in_place(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_prod(
        r: *mut banderwagon_fp,
        a: *const banderwagon_fp,
        b: *const banderwagon_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_mul_in_place(a: *mut banderwagon_fp, b: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_square(r: *mut banderwagon_fp, a: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_square_in_place(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_div2(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_inv(r: *mut banderwagon_fp, a: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_inv_in_place(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_ccopy(
        a: *mut banderwagon_fp,
        b: *const banderwagon_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_cswap(
        a: *mut banderwagon_fp,
        b: *mut banderwagon_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_cset_zero(a: *mut banderwagon_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_cset_one(a: *mut banderwagon_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_cneg_in_place(a: *mut banderwagon_fp, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_cadd_in_place(
        a: *mut banderwagon_fp,
        b: *const banderwagon_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_csub_in_place(
        a: *mut banderwagon_fp,
        b: *const banderwagon_fp,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_is_square(a: *const banderwagon_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_invsqrt(r: *mut banderwagon_fp, a: *const banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_invsqrt_in_place(
        r: *mut banderwagon_fp,
        a: *const banderwagon_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_sqrt_in_place(a: *mut banderwagon_fp);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_sqrt_if_square_in_place(a: *mut banderwagon_fp) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_sqrt_invsqrt(
        sqrt: *mut banderwagon_fp,
        invsqrt: *mut banderwagon_fp,
        a: *const banderwagon_fp,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_sqrt_invsqrt_if_square(
        sqrt: *mut banderwagon_fp,
        invsqrt: *mut banderwagon_fp,
        a: *const banderwagon_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_fp_sqrt_ratio_if_square(
        r: *mut banderwagon_fp,
        u: *const banderwagon_fp,
        v: *const banderwagon_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_is_eq(
        P: *const banderwagon_ec_aff,
        Q: *const banderwagon_ec_aff,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_is_neutral(P: *const banderwagon_ec_aff) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_set_neutral(P: *mut banderwagon_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_ccopy(
        P: *mut banderwagon_ec_aff,
        Q: *const banderwagon_ec_aff,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_is_on_curve(
        x: *const banderwagon_fp,
        y: *const banderwagon_fp,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_neg(P: *mut banderwagon_ec_aff, Q: *const banderwagon_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_neg_in_place(P: *mut banderwagon_ec_aff);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_aff_cneg(P: *mut banderwagon_ec_aff, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_is_eq(
        P: *const banderwagon_ec_prj,
        Q: *const banderwagon_ec_prj,
    ) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_is_neutral(P: *const banderwagon_ec_prj) -> secret_bool;
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_set_neutral(P: *mut banderwagon_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_ccopy(
        P: *mut banderwagon_ec_prj,
        Q: *const banderwagon_ec_prj,
        ctl: secret_bool,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_neg(P: *mut banderwagon_ec_prj, Q: *const banderwagon_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_neg_in_place(P: *mut banderwagon_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_cneg(P: *mut banderwagon_ec_prj, ctl: secret_bool);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_sum(
        r: *mut banderwagon_ec_prj,
        P: *const banderwagon_ec_prj,
        Q: *const banderwagon_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_double(r: *mut banderwagon_ec_prj, P: *const banderwagon_ec_prj);
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_add_in_place(
        P: *mut banderwagon_ec_prj,
        Q: *const banderwagon_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_diff(
        r: *mut banderwagon_ec_prj,
        P: *const banderwagon_ec_prj,
        Q: *const banderwagon_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_diff_in_place(
        P: *mut banderwagon_ec_prj,
        Q: *const banderwagon_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_mixed_diff_in_place(
        P: *mut banderwagon_ec_prj,
        Q: *const banderwagon_ec_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_affine(
        dst: *mut banderwagon_ec_aff,
        src: *const banderwagon_ec_prj,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_from_affine(
        dst: *mut banderwagon_ec_prj,
        src: *const banderwagon_ec_aff,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_batch_affine(
        dst: *const banderwagon_ec_aff,
        src: *const banderwagon_ec_prj,
        n: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_scalar_mul_big_coef(
        P: *mut banderwagon_ec_prj,
        scalar: *const big253,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_scalar_mul_fr_coef(
        P: *mut banderwagon_ec_prj,
        scalar: *const banderwagon_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_scalar_mul_big_coef_vartime(
        P: *mut banderwagon_ec_prj,
        scalar: *const big253,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_scalar_mul_fr_coef_vartime(
        P: *mut banderwagon_ec_prj,
        scalar: *const banderwagon_fr,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut banderwagon_ec_prj,
        coefs: *const big253,
        points: *const banderwagon_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_banderwagon_ec_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut banderwagon_ec_prj,
        coefs: *const banderwagon_fr,
        points: *const banderwagon_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_jac,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_jac,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_prj,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_prj,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_jac,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_jac,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_prj,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_prj,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_jac,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_jac,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_prj,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_prj,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_jac,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_jac,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_prj,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_prj,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_fp {
    pub raw: [byte; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_bls_fp"][::core::mem::size_of::<ctt_eth_bls_fp>() - 48usize];
    ["Alignment of ctt_eth_bls_fp"][::core::mem::align_of::<ctt_eth_bls_fp>() - 1usize];
    ["Offset of field: ctt_eth_bls_fp::raw"][::core::mem::offset_of!(ctt_eth_bls_fp, raw) - 0usize];
};
impl Default for ctt_eth_bls_fp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_fp2 {
    pub coords: [ctt_eth_bls_fp; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_bls_fp2"][::core::mem::size_of::<ctt_eth_bls_fp2>() - 96usize];
    ["Alignment of ctt_eth_bls_fp2"][::core::mem::align_of::<ctt_eth_bls_fp2>() - 1usize];
    ["Offset of field: ctt_eth_bls_fp2::coords"]
        [::core::mem::offset_of!(ctt_eth_bls_fp2, coords) - 0usize];
};
impl Default for ctt_eth_bls_fp2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ctt_eth_bls_seckey {
    pub raw: [byte; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_bls_seckey"][::core::mem::size_of::<ctt_eth_bls_seckey>() - 32usize];
    ["Alignment of ctt_eth_bls_seckey"][::core::mem::align_of::<ctt_eth_bls_seckey>() - 1usize];
    ["Offset of field: ctt_eth_bls_seckey::raw"]
        [::core::mem::offset_of!(ctt_eth_bls_seckey, raw) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_pubkey {
    pub x: ctt_eth_bls_fp,
    pub y: ctt_eth_bls_fp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_bls_pubkey"][::core::mem::size_of::<ctt_eth_bls_pubkey>() - 96usize];
    ["Alignment of ctt_eth_bls_pubkey"][::core::mem::align_of::<ctt_eth_bls_pubkey>() - 1usize];
    ["Offset of field: ctt_eth_bls_pubkey::x"]
        [::core::mem::offset_of!(ctt_eth_bls_pubkey, x) - 0usize];
    ["Offset of field: ctt_eth_bls_pubkey::y"]
        [::core::mem::offset_of!(ctt_eth_bls_pubkey, y) - 48usize];
};
impl Default for ctt_eth_bls_pubkey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_signature {
    pub x: ctt_eth_bls_fp2,
    pub y: ctt_eth_bls_fp2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_bls_signature"][::core::mem::size_of::<ctt_eth_bls_signature>() - 192usize];
    ["Alignment of ctt_eth_bls_signature"]
        [::core::mem::align_of::<ctt_eth_bls_signature>() - 1usize];
    ["Offset of field: ctt_eth_bls_signature::x"]
        [::core::mem::offset_of!(ctt_eth_bls_signature, x) - 0usize];
    ["Offset of field: ctt_eth_bls_signature::y"]
        [::core::mem::offset_of!(ctt_eth_bls_signature, y) - 96usize];
};
impl Default for ctt_eth_bls_signature {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_batch_sig_accumulator {
    _unused: [u8; 0],
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_bls_status {
    cttEthBls_Success = 0,
    cttEthBls_VerificationFailure = 1,
    cttEthBls_InputsLengthsMismatch = 2,
    cttEthBls_ZeroLengthAggregation = 3,
    cttEthBls_PointAtInfinity = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_span {
    pub data: *mut byte,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_span"][::core::mem::size_of::<ctt_span>() - 16usize];
    ["Alignment of ctt_span"][::core::mem::align_of::<ctt_span>() - 8usize];
    ["Offset of field: ctt_span::data"][::core::mem::offset_of!(ctt_span, data) - 0usize];
    ["Offset of field: ctt_span::len"][::core::mem::offset_of!(ctt_span, len) - 8usize];
};
impl Default for ctt_span {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_pubkey_is_zero(pubkey: *const ctt_eth_bls_pubkey) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_signature_is_zero(sig: *const ctt_eth_bls_signature) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_pubkeys_are_equal(
        a: *const ctt_eth_bls_pubkey,
        b: *const ctt_eth_bls_pubkey,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_signatures_are_equal(
        a: *const ctt_eth_bls_signature,
        b: *const ctt_eth_bls_signature,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Validate the secret key.\n\n  Regarding timing attacks, this will leak timing information only if the key is invalid.\n  Namely, the secret key is 0 or the secret key is too large."]
    pub fn ctt_eth_bls_validate_seckey(
        seckey: *const ctt_eth_bls_seckey,
    ) -> ctt_codec_scalar_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Validate the public key.\n\n  This is an expensive operation that can be cached."]
    pub fn ctt_eth_bls_validate_pubkey(pubkey: *const ctt_eth_bls_pubkey) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Validate the signature.\n\n  This is an expensive operation that can be cached."]
    pub fn ctt_eth_bls_validate_signature(
        pubkey: *const ctt_eth_bls_signature,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Serialize a secret key\n\n  Returns cttCodecScalar_Success if successful"]
    pub fn ctt_eth_bls_serialize_seckey(
        dst: *mut byte,
        seckey: *const ctt_eth_bls_seckey,
    ) -> ctt_codec_scalar_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Serialize a public key in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_serialize_pubkey_compressed(
        dst: *mut byte,
        pubkey: *const ctt_eth_bls_pubkey,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Serialize a signature in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_serialize_signature_compressed(
        dst: *mut byte,
        sig: *const ctt_eth_bls_signature,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a secret key\n  This also validates the secret key.\n\n  This is protected against side-channel unless your key is invalid.\n  In that case it will like whether it's all zeros or larger than the curve order."]
    pub fn ctt_eth_bls_deserialize_seckey(
        seckey: *mut ctt_eth_bls_seckey,
        src: *const byte,
    ) -> ctt_codec_scalar_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a public key in compressed (Zcash) format.\n  This does not validate the public key.\n  It is intended for cases where public keys are stored in a trusted location\n  and validation can be cached.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_pubkey_compressed_unchecked(
        pubkey: *mut ctt_eth_bls_pubkey,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a public_key in compressed (Zcash) format.\n  This also validates the public key.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_pubkey_compressed(
        pubkey: *mut ctt_eth_bls_pubkey,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a signature in compressed (Zcash) format.\n  This does not validate the signature.\n  It is intended for cases where public keys are stored in a trusted location\n  and validation can be cached.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_signature_compressed_unchecked(
        sig: *mut ctt_eth_bls_signature,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Deserialize a signature in compressed (Zcash) format.\n  This also validates the signature.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_signature_compressed(
        sig: *mut ctt_eth_bls_signature,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
unsafe extern "C" {
    #[doc = " Derive the public key matching with a secret key\n\n  Secret protection:\n  - A valid secret key will only leak that it is valid.\n  - An invalid secret key will leak whether it's all zero or larger than the curve order."]
    pub fn ctt_eth_bls_derive_pubkey(
        pubkey: *mut ctt_eth_bls_pubkey,
        seckey: *const ctt_eth_bls_seckey,
    );
}
unsafe extern "C" {
    #[doc = " Produce a signature for the message under the specified secret key\n  Signature is on BLS12-381 G2 (and public key on G1)\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - A secret key\n  - A message\n\n  Output:\n  - `signature` is overwritten with `message` signed with `secretKey`\n    with the scheme\n  - A status code indicating success or if the secret key is invalid.\n\n  Secret protection:\n  - A valid secret key will only leak that it is valid.\n  - An invalid secret key will leak whether it's all zero or larger than the curve order."]
    pub fn ctt_eth_bls_sign(
        sig: *mut ctt_eth_bls_signature,
        seckey: *const ctt_eth_bls_seckey,
        message: *const byte,
        message_len: usize,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Check that a signature is valid for a message\n  under the provided public key.\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - A public key initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - A message\n  - A signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  Output:\n  - a status code with verification success if signature is valid\n    or indicating verification failure\n\n  In particular, the public key and signature are assumed to be on curve and subgroup-checked."]
    pub fn ctt_eth_bls_verify(
        pubkey: *const ctt_eth_bls_pubkey,
        message: *const byte,
        message_len: usize,
        sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Check that a signature is valid for a message\n  under the aggregate of provided public keys.\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - A message\n  - A signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked."]
    pub fn ctt_eth_bls_fast_aggregate_verify(
        pubkeys: *const ctt_eth_bls_pubkey,
        pubkeys_len: usize,
        message: *const byte,
        message_len: usize,
        aggregate_sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Verify the aggregated signature of multiple (pubkey, message) pairs\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - Messages\n  - `len`: Number of elements in the `pubkeys` and `messages` arrays.\n  - a signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked.\n\n  To avoid splitting zeros and rogue keys attack:\n  1. Public keys signing the same message MUST be aggregated and checked for 0 before calling this function.\n  2. Augmentation or Proof of possessions must used for each public keys."]
    pub fn ctt_eth_bls_aggregate_verify(
        pubkeys: *const ctt_eth_bls_pubkey,
        messages: *const ctt_span,
        len: usize,
        aggregate_sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Verify that all (pubkey, message, signature) triplets are valid\n  returns `true` if all signatures are valid, `false` if at least one is invalid.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - Messages\n  - Signatures initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked.\n\n  To avoid splitting zeros and rogue keys attack:\n  1. Cryptographically-secure random bytes must be provided.\n  2. Augmentation or Proof of possessions must used for each public keys.\n\n  The secureRandomBytes will serve as input not under the attacker control to foil potential splitting zeros inputs.\n  The scheme assumes that the attacker cannot\n  resubmit 2^64 times forged (publickey, message, signature) triplets\n  against the same `secureRandomBytes`"]
    pub fn ctt_eth_bls_batch_verify(
        pubkeys: *const ctt_eth_bls_pubkey,
        messages: *const ctt_span,
        signatures: *const ctt_eth_bls_signature,
        len: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_bls_status;
}
unsafe extern "C" {
    #[doc = " Allocator function for the incomplete struct of the batch sig accumulator.\n Users of the C API *must* use this."]
    pub fn ctt_eth_bls_alloc_batch_sig_accumulator() -> *mut ctt_eth_bls_batch_sig_accumulator;
}
unsafe extern "C" {
    #[doc = " Function to free the storage allocated by the above.\n Users of the C API *must* use this."]
    pub fn ctt_eth_bls_free_batch_sig_accumulator(ptr: *mut ctt_eth_bls_batch_sig_accumulator);
}
unsafe extern "C" {
    #[doc = "  Initializes a Batch BLS Signature accumulator context.\n\n  This requires cryptographically secure random bytes\n  to defend against forged signatures that would not\n  verify individually but would verify while aggregated\n  https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407/14\n\n  An optional accumulator separation tag can be added\n  so that from a single source of randomness\n  each accumulatpr is seeded with a different state.\n  This is useful in multithreaded context."]
    pub fn ctt_eth_bls_init_batch_sig_accumulator(
        ctx: *mut ctt_eth_bls_batch_sig_accumulator,
        secure_random_bytes: *const byte,
        accum_sep_tag: *const byte,
        accum_sep_tag_len: usize,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Add a (public key, message, signature) triplet\n  to a BLS signature accumulator\n\n  Assumes that the public key and signature\n  have been group checked\n\n  Returns false if pubkey or signatures are the infinity points\n"]
    pub fn ctt_eth_bls_update_batch_sig_accumulator(
        ctx: *mut ctt_eth_bls_batch_sig_accumulator,
        pubkey: *const ctt_eth_bls_pubkey,
        message: *const byte,
        message_len: usize,
        signature: *const ctt_eth_bls_signature,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Finish batch and/or aggregate signature verification and returns the final result.\n\n  Returns false if nothing was accumulated\n  Rteturns false on verification failure"]
    pub fn ctt_eth_bls_final_verify_batch_sig_accumulator(
        ctx: *mut ctt_eth_bls_batch_sig_accumulator,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Verify that all (pubkey, message, signature) triplets are valid\n  returns `true` if all signatures are valid, `false` if at least one is invalid.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - Messages as an anonymous struct of `(data = byte*, length = size_t)` pairs\n    (the `View` type on the Nim side uses `int` for the length field, which depends on the\n    system)\n  - Signatures initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n  - `len`: number of elements in `pubkey`, `messages`, `sig` arrays\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked.\n\n  To avoid splitting zeros and rogue keys attack:\n  1. Cryptographically-secure random bytes must be provided.\n  2. Augmentation or Proof of possessions must used for each public keys.\n\n  The secureRandomBytes will serve as input not under the attacker control to foil potential splitting zeros inputs.\n  The scheme assumes that the attacker cannot\n  resubmit 2^64 times forged (publickey, message, signature) triplets\n  against the same `secureRandomBytes`"]
    pub fn ctt_eth_bls_batch_verify_parallel(
        tp: *const ctt_threadpool,
        pubkey: *const ctt_eth_bls_pubkey,
        messages: *const ctt_span,
        sig: *const ctt_eth_bls_signature,
        len: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_bls_status;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_context_struct {
    _unused: [u8; 0],
}
pub type ctt_eth_kzg_context = ctt_eth_kzg_context_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_commitment {
    pub raw: [byte; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_kzg_commitment"][::core::mem::size_of::<ctt_eth_kzg_commitment>() - 48usize];
    ["Alignment of ctt_eth_kzg_commitment"]
        [::core::mem::align_of::<ctt_eth_kzg_commitment>() - 1usize];
    ["Offset of field: ctt_eth_kzg_commitment::raw"]
        [::core::mem::offset_of!(ctt_eth_kzg_commitment, raw) - 0usize];
};
impl Default for ctt_eth_kzg_commitment {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_proof {
    pub raw: [byte; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_kzg_proof"][::core::mem::size_of::<ctt_eth_kzg_proof>() - 48usize];
    ["Alignment of ctt_eth_kzg_proof"][::core::mem::align_of::<ctt_eth_kzg_proof>() - 1usize];
    ["Offset of field: ctt_eth_kzg_proof::raw"]
        [::core::mem::offset_of!(ctt_eth_kzg_proof, raw) - 0usize];
};
impl Default for ctt_eth_kzg_proof {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_blob {
    pub raw: [byte; 131072usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_kzg_blob"][::core::mem::size_of::<ctt_eth_kzg_blob>() - 131072usize];
    ["Alignment of ctt_eth_kzg_blob"][::core::mem::align_of::<ctt_eth_kzg_blob>() - 1usize];
    ["Offset of field: ctt_eth_kzg_blob::raw"]
        [::core::mem::offset_of!(ctt_eth_kzg_blob, raw) - 0usize];
};
impl Default for ctt_eth_kzg_blob {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ctt_eth_kzg_opening_challenge {
    pub raw: [byte; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_kzg_opening_challenge"]
        [::core::mem::size_of::<ctt_eth_kzg_opening_challenge>() - 32usize];
    ["Alignment of ctt_eth_kzg_opening_challenge"]
        [::core::mem::align_of::<ctt_eth_kzg_opening_challenge>() - 1usize];
    ["Offset of field: ctt_eth_kzg_opening_challenge::raw"]
        [::core::mem::offset_of!(ctt_eth_kzg_opening_challenge, raw) - 0usize];
};
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ctt_eth_kzg_eval_at_challenge {
    pub raw: [byte; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ctt_eth_kzg_eval_at_challenge"]
        [::core::mem::size_of::<ctt_eth_kzg_eval_at_challenge>() - 32usize];
    ["Alignment of ctt_eth_kzg_eval_at_challenge"]
        [::core::mem::align_of::<ctt_eth_kzg_eval_at_challenge>() - 1usize];
    ["Offset of field: ctt_eth_kzg_eval_at_challenge::raw"]
        [::core::mem::offset_of!(ctt_eth_kzg_eval_at_challenge, raw) - 0usize];
};
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_kzg_status {
    cttEthKzg_Success = 0,
    cttEthKzg_VerificationFailure = 1,
    cttEthKzg_InputsLengthsMismatch = 2,
    cttEthKzg_ScalarZero = 3,
    cttEthKzg_ScalarLargerThanCurveOrder = 4,
    cttEthKzg_EccInvalidEncoding = 5,
    cttEthKzg_EccCoordinateGreaterThanOrEqualModulus = 6,
    cttEthKzg_EccPointNotOnCurve = 7,
    cttEthKzg_EccPointNotInSubgroup = 8,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_trusted_setup_status {
    cttEthTS_Success = 0,
    cttEthTS_MissingOrInaccessibleFile = 1,
    cttEthTS_InvalidFile = 2,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_trusted_setup_format {
    cttEthTSFormat_ckzg4844 = 0,
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Compute a commitment to the `blob`.\n  The commitment can be verified without needing the full `blob`\n\n  Mathematical description\n    commitment = [p()]\n\n    The blob data is used as a polynomial,\n    the polynomial is evaluated at powers of tau , a trusted setup.\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification opening challenge z.\n\n    with proof = [(p() - p(z)) / (-z)]"]
    pub fn ctt_eth_kzg_blob_to_kzg_commitment(
        ctx: *const ctt_eth_kzg_context,
        dst: *mut ctt_eth_kzg_commitment,
        blob: *const ctt_eth_kzg_blob,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Generate:\n  - A proof of correct evaluation.\n  - y = p(z), the evaluation of p at the opening challenge z, with p being the Blob interpreted as a polynomial.\n\n  Mathematical description\n    [proof] = [(p() - p(z)) / (-z)], with p() being the commitment, i.e. the evaluation of p at the powers of \n    The notation [a] corresponds to the scalar multiplication of a by the generator of 1\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification opening challenge z."]
    pub fn ctt_eth_kzg_compute_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        y: *mut ctt_eth_kzg_eval_at_challenge,
        blob: *const ctt_eth_kzg_blob,
        z: *const ctt_eth_kzg_opening_challenge,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Verify KZG proof\n  that p(z) == y where\n    - z is a random opening_challenge\n    - y is the evaluation of the \"KZG polynomial\" p at z\n    - commitment is p(), the evaluation of p at the trusted setup ,\n    - [proof] = [(p() - p(z)) / (-z)], ensure that p(z) evaluation was correct\n      without needing access to the polynomial p itself."]
    pub fn ctt_eth_kzg_verify_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        commitment: *const ctt_eth_kzg_commitment,
        z: *const ctt_eth_kzg_opening_challenge,
        y: *const ctt_eth_kzg_eval_at_challenge,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Given a blob, return the KZG proof that is used to verify it against the commitment.\n  This method does not verify that the commitment is correct with respect to `blob`."]
    pub fn ctt_eth_kzg_compute_blob_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Given a blob and a KZG proof, verify that the blob data corresponds to the provided commitment."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Verify `n` (blob, commitment, proof) sets efficiently\n\n  `n` is the number of verifications set\n  - if n is negative, this procedure returns verification failure\n  - if n is zero, this procedure returns verification success\n\n  `secure_random_bytes` random bytes must come from a cryptographically secure RNG\n  or computed through the Fiat-Shamir heuristic.\n  It serves as a random number\n  that is not in the control of a potential attacker to prevent potential\n  rogue commitments attacks due to homomorphic properties of pairings,\n  i.e. commitments that are linear combination of others and sum would be zero."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_batch(
        ctx: *const ctt_eth_kzg_context,
        blobs: *const ctt_eth_kzg_blob,
        commitments: *const ctt_eth_kzg_commitment,
        proofs: *const ctt_eth_kzg_proof,
        n: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Load trusted setup from path\n  Currently the only format supported `cttEthTSFormat_ckzg4844`\n  is from the reference implementation c-kzg-4844 text file"]
    pub fn ctt_eth_trusted_setup_load(
        ctx: *mut *mut ctt_eth_kzg_context,
        filepath: *const ::core::ffi::c_char,
        format: ctt_eth_trusted_setup_format,
    ) -> ctt_eth_trusted_setup_status;
}
unsafe extern "C" {
    #[doc = " Destroy a trusted setup"]
    pub fn ctt_eth_trusted_setup_delete(ctx: *mut ctt_eth_kzg_context);
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Compute a commitment to the `blob`.\n  The commitment can be verified without needing the full `blob`\n\n  Mathematical description\n    commitment = [p()]\n\n    The blob data is used as a polynomial,\n    the polynomial is evaluated at powers of tau , a trusted setup.\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification opening_challenge z.\n\n    with proof = [(p() - p(z)) / (-z)]"]
    pub fn ctt_eth_kzg_blob_to_kzg_commitment_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        dst: *mut ctt_eth_kzg_commitment,
        blob: *const ctt_eth_kzg_blob,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Generate:\n  - A proof of correct evaluation.\n  - y = p(z), the evaluation of p at the opening_challenge z, with p being the Blob interpreted as a polynomial.\n\n  Mathematical description\n    [proof] = [(p() - p(z)) / (-z)], with p() being the commitment, i.e. the evaluation of p at the powers of \n    The notation [a] corresponds to the scalar multiplication of a by the generator of 1\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification opening_challenge z."]
    pub fn ctt_eth_kzg_compute_kzg_proof_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        y: *mut ctt_eth_kzg_eval_at_challenge,
        blob: *const ctt_eth_kzg_blob,
        z: *const ctt_eth_kzg_opening_challenge,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Given a blob, return the KZG proof that is used to verify it against the commitment.\n  This method does not verify that the commitment is correct with respect to `blob`."]
    pub fn ctt_eth_kzg_compute_blob_kzg_proof_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Given a blob and a KZG proof, verify that the blob data corresponds to the provided commitment."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = " Verify `n` (blob, commitment, proof) sets efficiently\n\n  `n` is the number of verifications set\n  - if n is negative, this procedure returns verification failure\n  - if n is zero, this procedure returns verification success\n\n  `secure_random_bytes` random bytes must come from a cryptographically secure RNG\n  or computed through the Fiat-Shamir heuristic.\n  It serves as a random number\n  that is not in the control of a potential attacker to prevent potential\n  rogue commitments attacks due to homomorphic properties of pairings,\n  i.e. commitments that are linear combination of others and sum would be zero."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_batch_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        blobs: *const ctt_eth_kzg_blob,
        commitments: *const ctt_eth_kzg_commitment,
        proofs: *const ctt_eth_kzg_proof,
        n: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_kzg_status;
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_evm_status {
    cttEVM_Success = 0,
    cttEVM_InvalidInputSize = 1,
    cttEVM_InvalidOutputSize = 2,
    cttEVM_IntLargerThanModulus = 3,
    cttEVM_PointNotOnCurve = 4,
    cttEVM_PointNotInSubgroup = 5,
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  SHA256\n\n  Inputs:\n  - r: array with 32 bytes of storage for the result\n  - r_len: length of `r`. Must be 32\n  - inputs: Message to hash\n  - inputs_len: length of the inputs array\n\n  Output:\n  - 32-byte digest\n  - status code:\n    cttEVM_Success\n    cttEVM_InvalidOutputSize"]
    pub fn ctt_eth_evm_sha256(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Helper for `eth_evm_modexp`. Returns the size required to be allocated based on the\n  given input. Call this function first, then allocate space for the result buffer\n  in the call to `eth_evm_modexp` based on this function's result.\n\n  The size depends on the `modulusLen`, which is the third 32 bytes,\n  `inputs == [baseLen { 32 bytes }, exponentLen { 32 bytes }, modulusLen { 32 bytes }, ... ]`\n  in `inputs`.\n\n  The associated modulus length in bytes is the size required by the\n  result to `eth_evm_modexp`."]
    pub fn ctt_eth_evm_modexp_result_size(
        size: *mut u64,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Modular exponentiation\n\n  Name: MODEXP\n\n  Inputs:\n  - `baseLen`:     32 bytes base integer length (in bytes)\n  - `exponentLen`: 32 bytes exponent length (in bytes)\n  - `modulusLen`:  32 bytes modulus length (in bytes)\n  - `base`:        base integer (`baseLen` bytes)\n  - `exponent`:    exponent (`exponentLen` bytes)\n  - `modulus`:     modulus (`modulusLen` bytes)\n\n  Output:\n  - base (mod modulus)\n    The result buffer size `r` MUST match the modulusLen\n  - status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize if the lengths require more than 32-bit or 64-bit addressing (depending on hardware)\n    cttEVM_InvalidOutputSize\n\n  Spec\n    Yellow Paper Appendix E\n    EIP-198 - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-198.md\n\n  Hardware considerations:\n    This procedure stack allocates a table of (16+1)*modulusLen and many stack temporaries.\n    Make sure to validate gas costs and reject large inputs to bound stack usage."]
    pub fn ctt_eth_evm_modexp(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BN254_Snarks\n  (also called alt_bn128 in Ethereum specs\n   and bn256 in Ethereum tests)\n\n  Name: ECADD\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A G1 point Q with coordinates (Qx, Qy)\n\n  Each coordinate is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, Qx, Qy]\n  If the length is less than 128 bytes, input is virtually padded with zeros.\n  If the length is greater than 128 bytes, input is truncated to 128 bytes.\n\n  Output\n  - Output buffer MUST be of length 64 bytes\n  - A G1 point R = P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-196"]
    pub fn ctt_eth_evm_bn254_g1add(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve multiplication on BN254_Snarks\n  (also called alt_bn128 in Ethereum specs\n   and bn256 in Ethereum tests)\n\n  Name: ECMUL\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A scalar s in 0 ..< 2\n\n  Each coordinate is a 32-byte bigEndian integer\n  r is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, r]\n  If the length is less than 96 bytes, input is virtually padded with zeros.\n  If the length is greater than 96 bytes, input is truncated to 96 bytes.\n\n  Output\n  - Output buffer MUST be of length 64 bytes\n  - A G1 point R = [s]P\n  - Status codes:\n    cttEVM_Success\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-196"]
    pub fn ctt_eth_evm_bn254_g1mul(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve pairing check on BN254_Snarks\n  (also called alt_bn128 in Ethereum specs\n   and bn256 in Ethereum tests)\n\n  Name: ECPAIRING / Pairing check\n\n  Inputs:\n  - An array of [(P0, Q0), (P1, Q1), ... (Pk, Qk)] points in (G1, G2)\n\n  Output\n  - Output buffer MUST be of length 32 bytes\n  - 0 or 1 in uint256 BigEndian representation\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n    cttEVM_PointNotInSubgroup\n\n  Specs https://eips.ethereum.org/EIPS/eip-197\n        https://eips.ethereum.org/EIPS/eip-1108"]
    pub fn ctt_eth_evm_bn254_ecpairingcheck(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G1\n\n  Name: BLS12_G1ADD\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A G1 point Q with coordinates (Qx, Qy)\n  - Input buffer MUST be 256 bytes\n\n  Each coordinate is a 64-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, Qx, Qy]\n\n  Inputs are NOT subgroup-checked.\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G1 point R=P+Q with coordinates (Rx, Ry)\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g1add(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G2\n\n  Name: BLS12_G2ADD\n\n  Inputs:\n  - A G2 point P with coordinates (Px, Py)\n  - A G2 point Q with coordinates (Qx, Qy)\n  - Input buffer MUST be 512 bytes\n\n  Each coordinate is a 128-byte bigEndian integer pair (a+b) with  = -1\n  They are serialized concatenated in a byte array [Px, Py, Qx, Qy]\n\n  Inputs are NOT subgroup-checked.\n\n  Output\n  - Output buffer MUST be of length 256 bytes\n  - A G2 point R=P+Q with coordinates (Rx, Ry)\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g2add(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve scalar multiplication on BLS12-381 G1\n\n  Name: BLS12_G1MUL\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A scalar s in 0 ..< 2\n  - Input buffer MUST be 160 bytes\n\n  Each coordinate is a 64-byte bigEndian integer\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, s]\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G1 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g1mul(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve scalar multiplication on BLS12-381 G2\n\n  Name: BLS12_G2MUL\n\n  Inputs:\n  - A G2 point P with coordinates (Px, Py)\n  - A scalar s in 0 ..< 2\n  - Input buffer MUST be 288 bytes\n\n  Each coordinate is a 128-byte bigEndian integer pair (a+b) with  = -1\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, s]\n\n  Output\n  - Output buffer MUST be of length 256 bytes\n  - A G2 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g2mul(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G1\n\n  Name: BLS12_G1MSM\n\n  Inputs:\n  - A sequence of pairs of points\n    - G1 points P with coordinates (Px, Py)\n    - scalar s in 0 ..< 2\n  - Each pair MUST be 160 bytes\n  - The total length MUST be a multiple of 160 bytes\n\n  Each coordinate is a 64-byte bigEndian integer\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [(Px, Py, r), (Px, Py, r) ..., (Px, Py, r)]\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G1 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g1msm(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G2\n\n  Name: BLS12_G2MSM\n\n  Inputs:\n  - A sequence of pairs of points\n    - G2 points P with coordinates (Px, Py)\n    - scalar s in 0 ..< 2\n  - Each pair MUST be 288 bytes\n  - The total length MUST be a multiple of 288 bytes\n\n  Each coordinate is a 128-byte bigEndian integer pair (a+b) with  = -1\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [(Px, Py, r), (Px, Py, r) ..., (Px, Py, r)]\n\n  Output\n  - Output buffer MUST be of length 512 bytes\n  - A G2 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g2msm(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Elliptic curve pairing check on BLS12-381\n\n  Name: BLS12_PAIRINGCHECK\n\n  Inputs:\n  - An array of [(P0, Q0), (P1, Q1), ... (Pk, Qk)] points in (G1, G2)\n\n  Output\n  - Output buffer MUST be of length 32 bytes\n  - 0 or 1 in uint256 BigEndian representation\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n    cttEVM_PointNotInSubgroup\n\n  specs https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_pairingcheck(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Map a field element to G1\n\n  Name: BLS12_MAP_FP_TO_G1\n\n  Input:\n  - A field element in 0 ..< p, p the prime field of BLS12-381\n  - The length MUST be a 48-byte (381-bit) number serialized in 64-byte big-endian number\n\n  Output\n  - Output buffer MUST be of length 64 bytes\n  - A G1 point R with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_map_fp_to_g1(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "  Map an Fp2 extension field element to G2\n\n  Name: BLS12_MAP_FP2_TO_G2\n\n  Input:\n  - An extension field element in (0, 0) ..< (p, p), p the prime field of BLS12-381\n  - The length MUST be a tuple of 48-byte (381-bit) number serialized in tuple of 64-byte big-endian numbers\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G2 point R with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_map_fp2_to_g2(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
