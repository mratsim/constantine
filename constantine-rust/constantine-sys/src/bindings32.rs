/* automatically generated by rust-bindgen 0.69.1 */

pub type secret_word = usize;
pub type secret_bool = usize;
pub type byte = u8;
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_codec_scalar_status {
    cttCodecScalar_Success = 0,
    cttCodecScalar_Zero = 1,
    cttCodecScalar_ScalarLargerThanCurveOrder = 2,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_codec_ecc_status {
    cttCodecEcc_Success = 0,
    cttCodecEcc_InvalidEncoding = 1,
    cttCodecEcc_CoordinateGreaterThanOrEqualModulus = 2,
    cttCodecEcc_PointNotOnCurve = 3,
    cttCodecEcc_PointNotInSubgroup = 4,
    cttCodecEcc_PointAtInfinity = 5,
}
#[repr(C)]
#[derive(Debug)]
pub struct ctt_threadpool {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new threadpool that manages `num_threads` threads\n\n Initialize a threadpool that manages `num_threads` threads.\n\n A threadpool uses thread-local storage and (for external consumers)\n MUST be used from the thread that instantiated it.\n\n In particular, this means that:\n - runtime.LockOSThread() is needed from Go to avoid it allocating CGO calls to a new thread.\n - The threadpool cannot be ``Send`` in Rust or ``Clone`` (we can't deep-copy threads)\n\n 2 threadpools MUST NOT be instantiated at the same time from the same thread.\n\n Mixing with other libraries' threadpools and runtime\n will not impact correctness but may impact performance.\n"]
    pub fn ctt_threadpool_new(num_threads: ::core::ffi::c_int) -> *mut ctt_threadpool;
}
extern "C" {
    #[doc = " Wait until all pending tasks are processed and then shutdown the threadpool"]
    pub fn ctt_threadpool_shutdown(threadpool: *mut ctt_threadpool);
}
extern "C" {
    #[doc = " Query the number of threads available at the OS-level\n  to run computations.\n\n  This takes into account cores disabled at the OS-level, for example in a VM.\n  However this doesn't detect restrictions based on time quotas often used for Docker\n  or taskset / cpuset restrictions from cgroups.\n\n  For Simultaneous-Multithreading (SMT often call HyperThreading),\n  this returns the number of available logical cores."]
    pub fn ctt_cpu_get_num_threads_os() -> ::core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct ctt_sha256_context {
    message_schedule: [u32; 16usize],
    buf: [byte; 64usize],
    msgLen: u64,
}
#[test]
fn bindgen_test_layout_ctt_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_sha256_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_sha256_context>(),
        192usize,
        concat!("Size of: ", stringify!(ctt_sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_sha256_context>(),
        64usize,
        concat!("Alignment of ", stringify!(ctt_sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message_schedule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_sha256_context),
            "::",
            stringify!(message_schedule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_sha256_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msgLen) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_sha256_context),
            "::",
            stringify!(msgLen)
        )
    );
}
extern "C" {
    #[doc = " Initialize or reinitialize a Sha256 context."]
    pub fn ctt_sha256_init(ctx: *mut ctt_sha256_context);
}
extern "C" {
    #[doc = " Append a message to a SHA256 context\n  for incremental SHA256 computation\n\n  Security note: the tail of your message might be stored\n  in an internal buffer.\n  if sensitive content is used, ensure that\n  `ctx.finish(...)` and `ctx.clear()` are called as soon as possible.\n  Additionally ensure that the message(s) passed were stored\n  in memory considered secure for your threat model.\n\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_update(
        ctx: *mut ctt_sha256_context,
        message: *const byte,
        message_len: usize,
    );
}
extern "C" {
    #[doc = " Finalize a SHA256 computation and output the\n  message digest to the `digest` buffer.\n\n  Security note: this does not clear the internal buffer.\n  if sensitive content is used, use \"ctx.clear()\"\n  and also make sure that the message(s) passed were stored\n  in memory considered secure for your threat model.\n\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_finish(ctx: *mut ctt_sha256_context, digest: *mut byte);
}
extern "C" {
    #[doc = " Clear the context internal buffers\n  Security note:\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_clear(ctx: *mut ctt_sha256_context);
}
extern "C" {
    #[doc = " Compute the SHA-256 hash of message\n  and store the result in digest.\n  Optionally, clear the memory buffer used."]
    pub fn ctt_sha256_hash(
        digest: *mut byte,
        message: *const byte,
        message_len: usize,
        clear_memory: bool,
    );
}
extern "C" {
    pub fn ctt_csprng_sysrand(buffer: *mut ::core::ffi::c_void, len: usize) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct big381 {
    limbs: [secret_word; 12usize],
}
#[test]
fn bindgen_test_layout_big381() {
    const UNINIT: ::core::mem::MaybeUninit<big381> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<big381>(),
        48usize,
        concat!("Size of: ", stringify!(big381))
    );
    assert_eq!(
        ::core::mem::align_of::<big381>(),
        4usize,
        concat!("Alignment of ", stringify!(big381))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(big381),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct big255 {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_big255() {
    const UNINIT: ::core::mem::MaybeUninit<big255> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<big255>(),
        32usize,
        concat!("Size of: ", stringify!(big255))
    );
    assert_eq!(
        ::core::mem::align_of::<big255>(),
        4usize,
        concat!("Alignment of ", stringify!(big255))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(big255),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct big254 {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_big254() {
    const UNINIT: ::core::mem::MaybeUninit<big254> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<big254>(),
        32usize,
        concat!("Size of: ", stringify!(big254))
    );
    assert_eq!(
        ::core::mem::align_of::<big254>(),
        4usize,
        concat!("Alignment of ", stringify!(big254))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(big254),
            "::",
            stringify!(limbs)
        )
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_big254_unmarshalBE(dst: *mut big254, src: *const byte, src_len: usize) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_big254_marshalBE(dst: *mut byte, dst_len: usize, src: *const big254) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_big255_unmarshalBE(dst: *mut big255, src: *const byte, src_len: usize) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_big255_marshalBE(dst: *mut byte, dst_len: usize, src: *const big255) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_big381_unmarshalBE(dst: *mut big381, src: *const byte, src_len: usize) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_big381_marshalBE(dst: *mut byte, dst_len: usize, src: *const big381) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_fr {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_bls12_381_fr() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_fr>(),
        32usize,
        concat!("Size of: ", stringify!(bls12_381_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_fr>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_fp {
    limbs: [secret_word; 12usize],
}
#[test]
fn bindgen_test_layout_bls12_381_fp() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_fp>(),
        48usize,
        concat!("Size of: ", stringify!(bls12_381_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_fp>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_fp2 {
    c: [bls12_381_fp; 2usize],
}
#[test]
fn bindgen_test_layout_bls12_381_fp2() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_fp2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_fp2>(),
        96usize,
        concat!("Size of: ", stringify!(bls12_381_fp2))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_fp2>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_fp2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_fp2),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g1_aff {
    x: bls12_381_fp,
    y: bls12_381_fp,
}
#[test]
fn bindgen_test_layout_bls12_381_g1_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g1_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g1_aff>(),
        96usize,
        concat!("Size of: ", stringify!(bls12_381_g1_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g1_aff>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_g1_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g1_jac {
    x: bls12_381_fp,
    y: bls12_381_fp,
    z: bls12_381_fp,
}
#[test]
fn bindgen_test_layout_bls12_381_g1_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g1_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g1_jac>(),
        144usize,
        concat!("Size of: ", stringify!(bls12_381_g1_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g1_jac>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_g1_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g1_prj {
    x: bls12_381_fp,
    y: bls12_381_fp,
    z: bls12_381_fp,
}
#[test]
fn bindgen_test_layout_bls12_381_g1_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g1_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g1_prj>(),
        144usize,
        concat!("Size of: ", stringify!(bls12_381_g1_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g1_prj>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_g1_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_prj),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g2_aff {
    x: bls12_381_fp2,
    y: bls12_381_fp2,
}
#[test]
fn bindgen_test_layout_bls12_381_g2_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g2_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g2_aff>(),
        192usize,
        concat!("Size of: ", stringify!(bls12_381_g2_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g2_aff>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_g2_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g2_jac {
    x: bls12_381_fp2,
    y: bls12_381_fp2,
    z: bls12_381_fp2,
}
#[test]
fn bindgen_test_layout_bls12_381_g2_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g2_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g2_jac>(),
        288usize,
        concat!("Size of: ", stringify!(bls12_381_g2_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g2_jac>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_g2_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g2_prj {
    x: bls12_381_fp2,
    y: bls12_381_fp2,
    z: bls12_381_fp2,
}
#[test]
fn bindgen_test_layout_bls12_381_g2_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g2_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g2_prj>(),
        288usize,
        concat!("Size of: ", stringify!(bls12_381_g2_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g2_prj>(),
        4usize,
        concat!("Alignment of ", stringify!(bls12_381_g2_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    pub fn ctt_big255_from_bls12_381_fr(dst: *mut big255, src: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_from_big255(dst: *mut bls12_381_fr, src: *const big255);
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fr_unmarshalBE(
        dst: *mut bls12_381_fr,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fr_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bls12_381_fr,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_eq(a: *const bls12_381_fr, b: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_zero(a: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_one(a: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_minus_one(a: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_set_zero(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_set_one(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_set_minus_one(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_neg(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_neg_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_sum(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_add_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_diff(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_sub_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_double(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_double_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_prod(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_mul_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_square(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_square_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_div2(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_inv(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_inv_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_ccopy(a: *mut bls12_381_fr, b: *const bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cswap(a: *mut bls12_381_fr, b: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cset_zero(a: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cset_one(a: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cneg_in_place(a: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cadd_in_place(
        a: *mut bls12_381_fr,
        b: *const bls12_381_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_csub_in_place(
        a: *mut bls12_381_fr,
        b: *const bls12_381_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_big381_from_bls12_381_fp(dst: *mut big381, src: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_from_big381(dst: *mut bls12_381_fp, src: *const big381);
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fp_unmarshalBE(
        dst: *mut bls12_381_fp,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fp_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bls12_381_fp,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_eq(a: *const bls12_381_fp, b: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_zero(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_one(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_minus_one(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_set_zero(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_set_one(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_set_minus_one(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_neg(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_neg_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_sum(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_add_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_diff(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_sub_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_double(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_double_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_prod(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_mul_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_square(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_square_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_div2(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_inv(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_inv_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_ccopy(a: *mut bls12_381_fp, b: *const bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cswap(a: *mut bls12_381_fp, b: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cset_zero(a: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cset_one(a: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cneg_in_place(a: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cadd_in_place(
        a: *mut bls12_381_fp,
        b: *const bls12_381_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_csub_in_place(
        a: *mut bls12_381_fp,
        b: *const bls12_381_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_square(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_invsqrt(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_invsqrt_in_place(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_if_square_in_place(a: *mut bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_invsqrt(
        sqrt: *mut bls12_381_fp,
        invsqrt: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_invsqrt_if_square(
        sqrt: *mut bls12_381_fp,
        invsqrt: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_ratio_if_square(
        r: *mut bls12_381_fp,
        u: *const bls12_381_fp,
        v: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_eq(a: *const bls12_381_fp2, b: *const bls12_381_fp2)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_zero(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_one(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_minus_one(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_set_zero(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_set_one(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_set_minus_one(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_neg(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sum(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_add_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_diff(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sub_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_double(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_double_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conj(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conj_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conjneg(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conjneg_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_prod(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_mul_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_square(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_square_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_div2(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_inv(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_inv_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_ccopy(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cset_zero(a: *mut bls12_381_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cset_one(a: *mut bls12_381_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cneg_in_place(a: *mut bls12_381_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cadd_in_place(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_csub_in_place(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_square(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sqrt_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sqrt_if_square_in_place(a: *mut bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_eq(
        P: *const bls12_381_g1_aff,
        Q: *const bls12_381_g1_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_neutral(P: *const bls12_381_g1_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_set_neutral(P: *mut bls12_381_g1_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_ccopy(
        P: *mut bls12_381_g1_aff,
        Q: *const bls12_381_g1_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_on_curve(
        x: *const bls12_381_fp,
        y: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_neg(P: *mut bls12_381_g1_aff, Q: *const bls12_381_g1_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_neg_in_place(P: *mut bls12_381_g1_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_is_eq(
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_is_neutral(P: *const bls12_381_g1_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_set_neutral(P: *mut bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_ccopy(
        P: *mut bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_neg(P: *mut bls12_381_g1_jac, Q: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_neg_in_place(P: *mut bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_cneg_in_place(P: *mut bls12_381_g1_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_sum(
        r: *mut bls12_381_g1_jac,
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_add_in_place(P: *mut bls12_381_g1_jac, Q: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_diff(
        r: *mut bls12_381_g1_jac,
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_double(r: *mut bls12_381_g1_jac, P: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_double_in_place(P: *mut bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_affine(dst: *mut bls12_381_g1_aff, src: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_from_affine(
        dst: *mut bls12_381_g1_jac,
        src: *const bls12_381_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_batch_affine(
        dst: *const bls12_381_g1_aff,
        src: *const bls12_381_g1_jac,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_big_coef(
        P: *mut bls12_381_g1_jac,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_fr_coef(
        P: *mut bls12_381_g1_jac,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g1_jac,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g1_jac,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g1_jac,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g1_jac,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_is_eq(
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_is_neutral(P: *const bls12_381_g1_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_set_neutral(P: *mut bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_ccopy(
        P: *mut bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_neg(P: *mut bls12_381_g1_prj, Q: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_neg_in_place(P: *mut bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_cneg_in_place(P: *mut bls12_381_g1_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_sum(
        r: *mut bls12_381_g1_prj,
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_add_in_place(P: *mut bls12_381_g1_prj, Q: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_diff(
        r: *mut bls12_381_g1_prj,
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_double(r: *mut bls12_381_g1_prj, P: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_double_in_place(P: *mut bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_affine(dst: *mut bls12_381_g1_aff, src: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_from_affine(
        dst: *mut bls12_381_g1_prj,
        src: *const bls12_381_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_batch_affine(
        dst: *const bls12_381_g1_aff,
        src: *const bls12_381_g1_prj,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_big_coef(
        P: *mut bls12_381_g1_prj,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_fr_coef(
        P: *mut bls12_381_g1_prj,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g1_prj,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g1_prj,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g1_prj,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g1_prj,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_eq(
        P: *const bls12_381_g2_aff,
        Q: *const bls12_381_g2_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_neutral(P: *const bls12_381_g2_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_set_neutral(P: *mut bls12_381_g2_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_ccopy(
        P: *mut bls12_381_g2_aff,
        Q: *const bls12_381_g2_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_on_curve(
        x: *const bls12_381_fp2,
        y: *const bls12_381_fp2,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_neg(P: *mut bls12_381_g2_aff, Q: *const bls12_381_g2_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_neg_in_place(P: *mut bls12_381_g2_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_is_eq(
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_is_neutral(P: *const bls12_381_g2_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_set_neutral(P: *mut bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_ccopy(
        P: *mut bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_neg(P: *mut bls12_381_g2_jac, Q: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_neg_in_place(P: *mut bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_cneg_in_place(P: *mut bls12_381_g2_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_sum(
        r: *mut bls12_381_g2_jac,
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_add_in_place(P: *mut bls12_381_g2_jac, Q: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_diff(
        r: *mut bls12_381_g2_jac,
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_double(r: *mut bls12_381_g2_jac, P: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_double_in_place(P: *mut bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_affine(dst: *mut bls12_381_g2_aff, src: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_from_affine(
        dst: *mut bls12_381_g2_jac,
        src: *const bls12_381_g2_aff,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_batch_affine(
        dst: *const bls12_381_g2_aff,
        src: *const bls12_381_g2_jac,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_big_coef(
        P: *mut bls12_381_g2_jac,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_fr_coef(
        P: *mut bls12_381_g2_jac,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g2_jac,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g2_jac,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g2_jac,
        coefs: *const big255,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g2_jac,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_is_eq(
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_is_neutral(P: *const bls12_381_g2_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_set_neutral(P: *mut bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_ccopy(
        P: *mut bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_neg(P: *mut bls12_381_g2_prj, Q: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_neg_in_place(P: *mut bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_cneg_in_place(P: *mut bls12_381_g2_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_sum(
        r: *mut bls12_381_g2_prj,
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_add_in_place(P: *mut bls12_381_g2_prj, Q: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_diff(
        r: *mut bls12_381_g2_prj,
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_double(r: *mut bls12_381_g2_prj, P: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_double_in_place(P: *mut bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_affine(dst: *mut bls12_381_g2_aff, src: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_from_affine(
        dst: *mut bls12_381_g2_prj,
        src: *const bls12_381_g2_aff,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_batch_affine(
        dst: *const bls12_381_g2_aff,
        src: *const bls12_381_g2_prj,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_big_coef(
        P: *mut bls12_381_g2_prj,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_fr_coef(
        P: *mut bls12_381_g2_prj,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_big_coef_vartime(
        P: *mut bls12_381_g2_prj,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_scalar_mul_fr_coef_vartime(
        P: *mut bls12_381_g2_prj,
        scalar: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bls12_381_g2_prj,
        coefs: *const big255,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bls12_381_g2_prj,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_sswu_sha256(
        r: *mut bls12_381_g1_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_sswu_sha256(
        r: *mut bls12_381_g1_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_sswu_sha256(
        r: *mut bls12_381_g1_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_sswu_sha256(
        r: *mut bls12_381_g2_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_sswu_sha256(
        r: *mut bls12_381_g2_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_sswu_sha256(
        r: *mut bls12_381_g2_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_fr {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_bn254_snarks_fr() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_fr>(),
        32usize,
        concat!("Size of: ", stringify!(bn254_snarks_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_fr>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_fp {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_bn254_snarks_fp() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_fp>(),
        32usize,
        concat!("Size of: ", stringify!(bn254_snarks_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_fp>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_fp2 {
    c: [bn254_snarks_fp; 2usize],
}
#[test]
fn bindgen_test_layout_bn254_snarks_fp2() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_fp2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_fp2>(),
        64usize,
        concat!("Size of: ", stringify!(bn254_snarks_fp2))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_fp2>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_fp2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_fp2),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g1_aff {
    x: bn254_snarks_fp,
    y: bn254_snarks_fp,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g1_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g1_aff> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g1_aff>(),
        64usize,
        concat!("Size of: ", stringify!(bn254_snarks_g1_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g1_aff>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g1_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g1_jac {
    x: bn254_snarks_fp,
    y: bn254_snarks_fp,
    z: bn254_snarks_fp,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g1_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g1_jac> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g1_jac>(),
        96usize,
        concat!("Size of: ", stringify!(bn254_snarks_g1_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g1_jac>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g1_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g1_prj {
    x: bn254_snarks_fp,
    y: bn254_snarks_fp,
    z: bn254_snarks_fp,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g1_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g1_prj> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g1_prj>(),
        96usize,
        concat!("Size of: ", stringify!(bn254_snarks_g1_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g1_prj>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g1_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_prj),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g2_aff {
    x: bn254_snarks_fp2,
    y: bn254_snarks_fp2,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g2_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g2_aff> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g2_aff>(),
        128usize,
        concat!("Size of: ", stringify!(bn254_snarks_g2_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g2_aff>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g2_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g2_jac {
    x: bn254_snarks_fp2,
    y: bn254_snarks_fp2,
    z: bn254_snarks_fp2,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g2_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g2_jac> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g2_jac>(),
        192usize,
        concat!("Size of: ", stringify!(bn254_snarks_g2_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g2_jac>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g2_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g2_prj {
    x: bn254_snarks_fp2,
    y: bn254_snarks_fp2,
    z: bn254_snarks_fp2,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g2_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g2_prj> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g2_prj>(),
        192usize,
        concat!("Size of: ", stringify!(bn254_snarks_g2_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g2_prj>(),
        4usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g2_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    pub fn ctt_big254_from_bn254_snarks_fr(dst: *mut big254, src: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_from_big254(dst: *mut bn254_snarks_fr, src: *const big254);
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fr_unmarshalBE(
        dst: *mut bn254_snarks_fr,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fr_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bn254_snarks_fr,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_eq(
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_zero(a: *const bn254_snarks_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_one(a: *const bn254_snarks_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_minus_one(a: *const bn254_snarks_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_set_zero(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_set_one(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_set_minus_one(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_neg(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_neg_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_sum(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_add_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_diff(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_sub_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_double(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_double_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_prod(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_mul_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_square(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_square_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_div2(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_inv(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_inv_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_ccopy(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cswap(
        a: *mut bn254_snarks_fr,
        b: *mut bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cset_zero(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cset_one(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cneg_in_place(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cadd_in_place(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_csub_in_place(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_big254_from_bn254_snarks_fp(dst: *mut big254, src: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_from_big254(dst: *mut bn254_snarks_fp, src: *const big254);
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fp_unmarshalBE(
        dst: *mut bn254_snarks_fp,
        src: *const byte,
        src_len: usize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fp_marshalBE(
        dst: *mut byte,
        dst_len: usize,
        src: *const bn254_snarks_fp,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_eq(
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_zero(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_one(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_minus_one(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_set_zero(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_set_one(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_set_minus_one(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_neg(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_neg_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sum(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_add_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_diff(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sub_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_double(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_double_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_prod(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_mul_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_square(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_square_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_div2(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_inv(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_inv_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_ccopy(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cswap(
        a: *mut bn254_snarks_fp,
        b: *mut bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cset_zero(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cset_one(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cneg_in_place(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cadd_in_place(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_csub_in_place(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_square(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_invsqrt(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_invsqrt_in_place(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_if_square_in_place(a: *mut bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_invsqrt(
        sqrt: *mut bn254_snarks_fp,
        invsqrt: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_invsqrt_if_square(
        sqrt: *mut bn254_snarks_fp,
        invsqrt: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_ratio_if_square(
        r: *mut bn254_snarks_fp,
        u: *const bn254_snarks_fp,
        v: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_eq(
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_zero(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_one(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_minus_one(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_zero(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_one(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_minus_one(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_neg(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sum(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_add_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_diff(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sub_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_double(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_double_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conj(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conj_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conjneg(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conjneg_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_prod(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_mul_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_square(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_square_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_div2(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_inv(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_inv_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_ccopy(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cset_zero(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cset_one(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cneg_in_place(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cadd_in_place(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_csub_in_place(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_square(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sqrt_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sqrt_if_square_in_place(a: *mut bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_eq(
        P: *const bn254_snarks_g1_aff,
        Q: *const bn254_snarks_g1_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_neutral(P: *const bn254_snarks_g1_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_set_neutral(P: *mut bn254_snarks_g1_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_ccopy(
        P: *mut bn254_snarks_g1_aff,
        Q: *const bn254_snarks_g1_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_on_curve(
        x: *const bn254_snarks_fp,
        y: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_neg(P: *mut bn254_snarks_g1_aff, Q: *const bn254_snarks_g1_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_neg_in_place(P: *mut bn254_snarks_g1_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_is_eq(
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_is_neutral(P: *const bn254_snarks_g1_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_set_neutral(P: *mut bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_ccopy(
        P: *mut bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_neg(P: *mut bn254_snarks_g1_jac, Q: *const bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_neg_in_place(P: *mut bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_cneg_in_place(P: *mut bn254_snarks_g1_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_sum(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_add_in_place(
        P: *mut bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_diff(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_double(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_double_in_place(P: *mut bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_affine(
        dst: *mut bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_from_affine(
        dst: *mut bn254_snarks_g1_jac,
        src: *const bn254_snarks_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_batch_affine(
        dst: *const bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_jac,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_big_coef(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g1_jac,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g1_jac,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g1_jac,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_is_eq(
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_is_neutral(P: *const bn254_snarks_g1_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_set_neutral(P: *mut bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_ccopy(
        P: *mut bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_neg(P: *mut bn254_snarks_g1_prj, Q: *const bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_neg_in_place(P: *mut bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_cneg_in_place(P: *mut bn254_snarks_g1_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_sum(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_add_in_place(
        P: *mut bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_diff(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_double(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_double_in_place(P: *mut bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_affine(
        dst: *mut bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_from_affine(
        dst: *mut bn254_snarks_g1_prj,
        src: *const bn254_snarks_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_batch_affine(
        dst: *const bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_prj,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_big_coef(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g1_prj,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g1_prj,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g1_prj,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_eq(
        P: *const bn254_snarks_g2_aff,
        Q: *const bn254_snarks_g2_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_neutral(P: *const bn254_snarks_g2_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_set_neutral(P: *mut bn254_snarks_g2_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_ccopy(
        P: *mut bn254_snarks_g2_aff,
        Q: *const bn254_snarks_g2_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_on_curve(
        x: *const bn254_snarks_fp2,
        y: *const bn254_snarks_fp2,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_neg(P: *mut bn254_snarks_g2_aff, Q: *const bn254_snarks_g2_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_neg_in_place(P: *mut bn254_snarks_g2_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_is_eq(
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_is_neutral(P: *const bn254_snarks_g2_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_set_neutral(P: *mut bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_ccopy(
        P: *mut bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_neg(P: *mut bn254_snarks_g2_jac, Q: *const bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_neg_in_place(P: *mut bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_cneg_in_place(P: *mut bn254_snarks_g2_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_sum(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_add_in_place(
        P: *mut bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_diff(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_double(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_double_in_place(P: *mut bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_affine(
        dst: *mut bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_from_affine(
        dst: *mut bn254_snarks_g2_jac,
        src: *const bn254_snarks_g2_aff,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_batch_affine(
        dst: *const bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_jac,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_big_coef(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g2_jac,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g2_jac,
        coefs: *const big254,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g2_jac,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_is_eq(
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_is_neutral(P: *const bn254_snarks_g2_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_set_neutral(P: *mut bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_ccopy(
        P: *mut bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_neg(P: *mut bn254_snarks_g2_prj, Q: *const bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_neg_in_place(P: *mut bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_cneg_in_place(P: *mut bn254_snarks_g2_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_sum(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_add_in_place(
        P: *mut bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_diff(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_double(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_double_in_place(P: *mut bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_affine(
        dst: *mut bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_from_affine(
        dst: *mut bn254_snarks_g2_prj,
        src: *const bn254_snarks_g2_aff,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_batch_affine(
        dst: *const bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_prj,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_big_coef(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_fr_coef(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_big_coef_vartime(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const big254,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_scalar_mul_fr_coef_vartime(
        P: *mut bn254_snarks_g2_prj,
        scalar: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut bn254_snarks_g2_prj,
        coefs: *const big254,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut bn254_snarks_g2_prj,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g2_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_svdw_sha256(
        r: *mut bn254_snarks_g1_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_svdw_sha256(
        r: *mut bn254_snarks_g1_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_svdw_sha256(
        r: *mut bn254_snarks_g1_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_svdw_sha256(
        r: *mut bn254_snarks_g2_aff,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_svdw_sha256(
        r: *mut bn254_snarks_g2_jac,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_svdw_sha256(
        r: *mut bn254_snarks_g2_prj,
        augmentation: *const byte,
        augmentation_len: usize,
        message: *const byte,
        message_len: usize,
        domainSepTag: *const byte,
        domainSepTag_len: usize,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_fr {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_pallas_fr() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_fr>(),
        32usize,
        concat!("Size of: ", stringify!(pallas_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_fr>(),
        4usize,
        concat!("Alignment of ", stringify!(pallas_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_fp {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_pallas_fp() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_fp>(),
        32usize,
        concat!("Size of: ", stringify!(pallas_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_fp>(),
        4usize,
        concat!("Alignment of ", stringify!(pallas_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_ec_aff {
    x: pallas_fp,
    y: pallas_fp,
}
#[test]
fn bindgen_test_layout_pallas_ec_aff() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_ec_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_ec_aff>(),
        64usize,
        concat!("Size of: ", stringify!(pallas_ec_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_ec_aff>(),
        4usize,
        concat!("Alignment of ", stringify!(pallas_ec_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_ec_jac {
    x: pallas_fp,
    y: pallas_fp,
    z: pallas_fp,
}
#[test]
fn bindgen_test_layout_pallas_ec_jac() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_ec_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_ec_jac>(),
        96usize,
        concat!("Size of: ", stringify!(pallas_ec_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_ec_jac>(),
        4usize,
        concat!("Alignment of ", stringify!(pallas_ec_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_ec_prj {
    x: pallas_fp,
    y: pallas_fp,
    z: pallas_fp,
}
#[test]
fn bindgen_test_layout_pallas_ec_prj() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_ec_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_ec_prj>(),
        96usize,
        concat!("Size of: ", stringify!(pallas_ec_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_ec_prj>(),
        4usize,
        concat!("Alignment of ", stringify!(pallas_ec_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    pub fn ctt_big255_from_pallas_fr(dst: *mut big255, src: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_from_big255(dst: *mut pallas_fr, src: *const big255);
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fr_unmarshalBE(dst: *mut pallas_fr, src: *const byte, src_len: usize)
        -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fr_marshalBE(dst: *mut byte, dst_len: usize, src: *const pallas_fr) -> bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_eq(a: *const pallas_fr, b: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_zero(a: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_one(a: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_minus_one(a: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_set_zero(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_set_one(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_set_minus_one(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_neg(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_neg_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_sum(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_add_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_diff(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_sub_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_double(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_double_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_prod(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_mul_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_square(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_square_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_div2(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_inv(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_inv_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_ccopy(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cswap(a: *mut pallas_fr, b: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cset_zero(a: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cset_one(a: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cneg_in_place(a: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cadd_in_place(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_csub_in_place(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_big255_from_pallas_fp(dst: *mut big255, src: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_from_big255(dst: *mut pallas_fp, src: *const big255);
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fp_unmarshalBE(dst: *mut pallas_fp, src: *const byte, src_len: usize)
        -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fp_marshalBE(dst: *mut byte, dst_len: usize, src: *const pallas_fp) -> bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_eq(a: *const pallas_fp, b: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_zero(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_one(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_minus_one(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_set_zero(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_set_one(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_set_minus_one(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_neg(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_neg_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_sum(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_add_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_diff(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_sub_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_double(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_double_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_prod(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_mul_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_square(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_square_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_div2(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_inv(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_inv_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_ccopy(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cswap(a: *mut pallas_fp, b: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cset_zero(a: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cset_one(a: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cneg_in_place(a: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cadd_in_place(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_csub_in_place(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_is_square(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_invsqrt(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_invsqrt_in_place(r: *mut pallas_fp, a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_if_square_in_place(a: *mut pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_invsqrt(
        sqrt: *mut pallas_fp,
        invsqrt: *mut pallas_fp,
        a: *const pallas_fp,
    );
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_invsqrt_if_square(
        sqrt: *mut pallas_fp,
        invsqrt: *mut pallas_fp,
        a: *const pallas_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_ratio_if_square(
        r: *mut pallas_fp,
        u: *const pallas_fp,
        v: *const pallas_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_is_eq(P: *const pallas_ec_aff, Q: *const pallas_ec_aff)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_is_neutral(P: *const pallas_ec_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_set_neutral(P: *mut pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_aff_ccopy(
        P: *mut pallas_ec_aff,
        Q: *const pallas_ec_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_aff_is_on_curve(x: *const pallas_fp, y: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_neg(P: *mut pallas_ec_aff, Q: *const pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_aff_neg_in_place(P: *mut pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_is_eq(P: *const pallas_ec_jac, Q: *const pallas_ec_jac)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_jac_is_neutral(P: *const pallas_ec_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_jac_set_neutral(P: *mut pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_ccopy(
        P: *mut pallas_ec_jac,
        Q: *const pallas_ec_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_neg(P: *mut pallas_ec_jac, Q: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_neg_in_place(P: *mut pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_cneg_in_place(P: *mut pallas_ec_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_sum(
        r: *mut pallas_ec_jac,
        P: *const pallas_ec_jac,
        Q: *const pallas_ec_jac,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_add_in_place(P: *mut pallas_ec_jac, Q: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_diff(
        r: *mut pallas_ec_jac,
        P: *const pallas_ec_jac,
        Q: *const pallas_ec_jac,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_double(r: *mut pallas_ec_jac, P: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_double_in_place(P: *mut pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_affine(dst: *mut pallas_ec_aff, src: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_from_affine(dst: *mut pallas_ec_jac, src: *const pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_batch_affine(
        dst: *const pallas_ec_aff,
        src: *const pallas_ec_jac,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_big_coef(P: *mut pallas_ec_jac, scalar: *const big255);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_fr_coef(P: *mut pallas_ec_jac, scalar: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_big_coef_vartime(
        P: *mut pallas_ec_jac,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_scalar_mul_fr_coef_vartime(
        P: *mut pallas_ec_jac,
        scalar: *const pallas_fr,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut pallas_ec_jac,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut pallas_ec_jac,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_is_eq(P: *const pallas_ec_prj, Q: *const pallas_ec_prj)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_prj_is_neutral(P: *const pallas_ec_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_prj_set_neutral(P: *mut pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_ccopy(
        P: *mut pallas_ec_prj,
        Q: *const pallas_ec_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_neg(P: *mut pallas_ec_prj, Q: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_neg_in_place(P: *mut pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_cneg_in_place(P: *mut pallas_ec_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_sum(
        r: *mut pallas_ec_prj,
        P: *const pallas_ec_prj,
        Q: *const pallas_ec_prj,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_add_in_place(P: *mut pallas_ec_prj, Q: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_diff(
        r: *mut pallas_ec_prj,
        P: *const pallas_ec_prj,
        Q: *const pallas_ec_prj,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_double(r: *mut pallas_ec_prj, P: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_double_in_place(P: *mut pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_affine(dst: *mut pallas_ec_aff, src: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_from_affine(dst: *mut pallas_ec_prj, src: *const pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_batch_affine(
        dst: *const pallas_ec_aff,
        src: *const pallas_ec_prj,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_big_coef(P: *mut pallas_ec_prj, scalar: *const big255);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_fr_coef(P: *mut pallas_ec_prj, scalar: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_big_coef_vartime(
        P: *mut pallas_ec_prj,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_scalar_mul_fr_coef_vartime(
        P: *mut pallas_ec_prj,
        scalar: *const pallas_fr,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut pallas_ec_prj,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut pallas_ec_prj,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_fr {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_vesta_fr() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_fr>(),
        32usize,
        concat!("Size of: ", stringify!(vesta_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_fr>(),
        4usize,
        concat!("Alignment of ", stringify!(vesta_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_fp {
    limbs: [secret_word; 8usize],
}
#[test]
fn bindgen_test_layout_vesta_fp() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_fp>(),
        32usize,
        concat!("Size of: ", stringify!(vesta_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_fp>(),
        4usize,
        concat!("Alignment of ", stringify!(vesta_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_ec_aff {
    x: vesta_fp,
    y: vesta_fp,
}
#[test]
fn bindgen_test_layout_vesta_ec_aff() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_ec_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_ec_aff>(),
        64usize,
        concat!("Size of: ", stringify!(vesta_ec_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_ec_aff>(),
        4usize,
        concat!("Alignment of ", stringify!(vesta_ec_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_ec_jac {
    x: vesta_fp,
    y: vesta_fp,
    z: vesta_fp,
}
#[test]
fn bindgen_test_layout_vesta_ec_jac() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_ec_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_ec_jac>(),
        96usize,
        concat!("Size of: ", stringify!(vesta_ec_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_ec_jac>(),
        4usize,
        concat!("Alignment of ", stringify!(vesta_ec_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_ec_prj {
    x: vesta_fp,
    y: vesta_fp,
    z: vesta_fp,
}
#[test]
fn bindgen_test_layout_vesta_ec_prj() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_ec_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_ec_prj>(),
        96usize,
        concat!("Size of: ", stringify!(vesta_ec_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_ec_prj>(),
        4usize,
        concat!("Alignment of ", stringify!(vesta_ec_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    pub fn ctt_big255_from_vesta_fr(dst: *mut big255, src: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_from_big255(dst: *mut vesta_fr, src: *const big255);
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fr_unmarshalBE(dst: *mut vesta_fr, src: *const byte, src_len: usize) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fr_marshalBE(dst: *mut byte, dst_len: usize, src: *const vesta_fr) -> bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_eq(a: *const vesta_fr, b: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_zero(a: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_one(a: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_minus_one(a: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_set_zero(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_set_one(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_set_minus_one(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_neg(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_neg_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_sum(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_add_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_diff(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_sub_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_double(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_double_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_prod(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_mul_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_square(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_square_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_div2(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_inv(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_inv_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_ccopy(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cswap(a: *mut vesta_fr, b: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cset_zero(a: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cset_one(a: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cneg_in_place(a: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cadd_in_place(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_csub_in_place(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_big255_from_vesta_fp(dst: *mut big255, src: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_from_big255(dst: *mut vesta_fp, src: *const big255);
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fp_unmarshalBE(dst: *mut vesta_fp, src: *const byte, src_len: usize) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fp_marshalBE(dst: *mut byte, dst_len: usize, src: *const vesta_fp) -> bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_eq(a: *const vesta_fp, b: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_zero(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_one(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_minus_one(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_set_zero(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_set_one(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_set_minus_one(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_neg(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_neg_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_sum(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_add_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_diff(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_sub_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_double(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_double_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_prod(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_mul_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_square(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_square_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_div2(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_inv(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_inv_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_ccopy(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cswap(a: *mut vesta_fp, b: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cset_zero(a: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cset_one(a: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cneg_in_place(a: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cadd_in_place(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_csub_in_place(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_is_square(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_invsqrt(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_invsqrt_in_place(r: *mut vesta_fp, a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_if_square_in_place(a: *mut vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_invsqrt(
        sqrt: *mut vesta_fp,
        invsqrt: *mut vesta_fp,
        a: *const vesta_fp,
    );
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_invsqrt_if_square(
        sqrt: *mut vesta_fp,
        invsqrt: *mut vesta_fp,
        a: *const vesta_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_ratio_if_square(
        r: *mut vesta_fp,
        u: *const vesta_fp,
        v: *const vesta_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_is_eq(P: *const vesta_ec_aff, Q: *const vesta_ec_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_is_neutral(P: *const vesta_ec_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_set_neutral(P: *mut vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_aff_ccopy(P: *mut vesta_ec_aff, Q: *const vesta_ec_aff, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_aff_is_on_curve(x: *const vesta_fp, y: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_neg(P: *mut vesta_ec_aff, Q: *const vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_aff_neg_in_place(P: *mut vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_is_eq(P: *const vesta_ec_jac, Q: *const vesta_ec_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_jac_is_neutral(P: *const vesta_ec_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_jac_set_neutral(P: *mut vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_ccopy(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_neg(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_neg_in_place(P: *mut vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_cneg_in_place(P: *mut vesta_ec_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_sum(
        r: *mut vesta_ec_jac,
        P: *const vesta_ec_jac,
        Q: *const vesta_ec_jac,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_add_in_place(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_diff(
        r: *mut vesta_ec_jac,
        P: *const vesta_ec_jac,
        Q: *const vesta_ec_jac,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_double(r: *mut vesta_ec_jac, P: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_double_in_place(P: *mut vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_affine(dst: *mut vesta_ec_aff, src: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_from_affine(dst: *mut vesta_ec_jac, src: *const vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_batch_affine(
        dst: *const vesta_ec_aff,
        src: *const vesta_ec_jac,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_big_coef(P: *mut vesta_ec_jac, scalar: *const big255);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_fr_coef(P: *mut vesta_ec_jac, scalar: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_big_coef_vartime(
        P: *mut vesta_ec_jac,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_scalar_mul_fr_coef_vartime(
        P: *mut vesta_ec_jac,
        scalar: *const vesta_fr,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_big_coefs_vartime(
        r: *mut vesta_ec_jac,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_fr_coefs_vartime(
        r: *mut vesta_ec_jac,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_is_eq(P: *const vesta_ec_prj, Q: *const vesta_ec_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_prj_is_neutral(P: *const vesta_ec_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_prj_set_neutral(P: *mut vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_ccopy(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_neg(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_neg_in_place(P: *mut vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_cneg_in_place(P: *mut vesta_ec_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_sum(
        r: *mut vesta_ec_prj,
        P: *const vesta_ec_prj,
        Q: *const vesta_ec_prj,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_add_in_place(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_diff(
        r: *mut vesta_ec_prj,
        P: *const vesta_ec_prj,
        Q: *const vesta_ec_prj,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_double(r: *mut vesta_ec_prj, P: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_double_in_place(P: *mut vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_affine(dst: *mut vesta_ec_aff, src: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_from_affine(dst: *mut vesta_ec_prj, src: *const vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_batch_affine(
        dst: *const vesta_ec_aff,
        src: *const vesta_ec_prj,
        n: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_big_coef(P: *mut vesta_ec_prj, scalar: *const big255);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_fr_coef(P: *mut vesta_ec_prj, scalar: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_big_coef_vartime(
        P: *mut vesta_ec_prj,
        scalar: *const big255,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_scalar_mul_fr_coef_vartime(
        P: *mut vesta_ec_prj,
        scalar: *const vesta_fr,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_big_coefs_vartime(
        r: *mut vesta_ec_prj,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_fr_coefs_vartime(
        r: *mut vesta_ec_prj,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    #[must_use]
    #[doc = " Validate a scalar\n  Regarding timing attacks, this will leak information\n  if the scalar is 0 or larger than the curve order."]
    pub fn ctt_bls12_381_validate_scalar(scalar: *const big255) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate a G1 point\n  This is an expensive operation that can be cached"]
    pub fn ctt_bls12_381_validate_g1(point: *const bls12_381_g1_aff) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate a G2 point\n  This is an expensive operation that can be cached"]
    pub fn ctt_bls12_381_validate_g2(point: *const bls12_381_g2_aff) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a scalar\n  Returns cttCodecScalar_Success if successful"]
    pub fn ctt_bls12_381_serialize_scalar(
        dst: *mut byte,
        scalar: *const big255,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a scalar\n  Also validates the scalar range\n\n  This is protected against side-channel unless the scalar is invalid.\n  In that case it will leak whether it's all zeros or larger than the curve order.\n\n  This special-cases (and leaks) 0 scalar as this is a special-case in most protocols\n  or completely invalid (for secret keys)."]
    pub fn ctt_bls12_381_deserialize_scalar(
        dst: *mut big255,
        src: *const byte,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a BLS12-381 G1 point in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_bls12_381_serialize_g1_compressed(
        dst: *mut byte,
        src: *const bls12_381_g1_aff,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G1 point in compressed (Zcash) format.\n\n  Warning ⚠:\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks."]
    pub fn ctt_bls12_381_deserialize_g1_compressed_unchecked(
        dst: *mut bls12_381_g1_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G1 point in compressed (Zcash) format\n  This also validates the G1 point"]
    pub fn ctt_bls12_381_deserialize_g1_compressed(
        dst: *mut bls12_381_g1_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a BLS12-381 G2 point in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_bls12_381_serialize_g2_compressed(
        dst: *mut byte,
        src: *const bls12_381_g2_aff,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G2 point in compressed (Zcash) format.\n\n  Warning ⚠:\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks."]
    pub fn ctt_bls12_381_deserialize_g2_compressed_unchecked(
        dst: *mut bls12_381_g2_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G2 point in compressed (Zcash) format\n  This also validates the G2 point"]
    pub fn ctt_bls12_381_deserialize_g2_compressed(
        dst: *mut bls12_381_g2_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_jac,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_jac,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_prj,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_prj,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_jac,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_jac,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_prj,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_prj,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_jac,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_jac,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_prj,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_prj,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_jac,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_jac,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_prj,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_prj,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_fp {
    raw: [byte; 48usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_fp() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_fp>(),
        48usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_fp>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_fp),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_fp2 {
    coords: [ctt_eth_bls_fp; 2usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_fp2() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_fp2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_fp2>(),
        96usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_fp2))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_fp2>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_fp2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coords) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_fp2),
            "::",
            stringify!(coords)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_seckey {
    raw: [byte; 32usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_seckey() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_seckey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_seckey>(),
        32usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_seckey))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_seckey>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_seckey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_seckey),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_pubkey {
    x: ctt_eth_bls_fp,
    y: ctt_eth_bls_fp,
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_pubkey() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_pubkey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_pubkey>(),
        96usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_pubkey))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_pubkey>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_pubkey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_pubkey),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_pubkey),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_signature {
    x: ctt_eth_bls_fp2,
    y: ctt_eth_bls_fp2,
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_signature() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_signature> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_signature>(),
        192usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_signature))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_signature>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_signature))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_signature),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_signature),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_batch_sig_accumulator {
    _unused: [u8; 0],
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_bls_status {
    cttEthBls_Success = 0,
    cttEthBls_VerificationFailure = 1,
    cttEthBls_InputsLengthsMismatch = 2,
    cttEthBls_ZeroLengthAggregation = 3,
    cttEthBls_PointAtInfinity = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_span {
    data: *mut byte,
    len: usize,
}
#[test]
fn bindgen_test_layout_ctt_span() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_span> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_span>(),
        8usize,
        concat!("Size of: ", stringify!(ctt_span))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_span>(),
        4usize,
        concat!("Alignment of ", stringify!(ctt_span))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_span),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_span),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_pubkey_is_zero(pubkey: *const ctt_eth_bls_pubkey) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_signature_is_zero(sig: *const ctt_eth_bls_signature) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_pubkeys_are_equal(
        a: *const ctt_eth_bls_pubkey,
        b: *const ctt_eth_bls_pubkey,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_signatures_are_equal(
        a: *const ctt_eth_bls_signature,
        b: *const ctt_eth_bls_signature,
    ) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = " Validate the secret key.\n\n  Regarding timing attacks, this will leak timing information only if the key is invalid.\n  Namely, the secret key is 0 or the secret key is too large."]
    pub fn ctt_eth_bls_validate_seckey(
        seckey: *const ctt_eth_bls_seckey,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate the public key.\n\n  This is an expensive operation that can be cached."]
    pub fn ctt_eth_bls_validate_pubkey(pubkey: *const ctt_eth_bls_pubkey) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate the signature.\n\n  This is an expensive operation that can be cached."]
    pub fn ctt_eth_bls_validate_signature(
        pubkey: *const ctt_eth_bls_signature,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a secret key\n\n  Returns cttCodecScalar_Success if successful"]
    pub fn ctt_eth_bls_serialize_seckey(
        dst: *mut byte,
        seckey: *const ctt_eth_bls_seckey,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a public key in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_serialize_pubkey_compressed(
        dst: *mut byte,
        pubkey: *const ctt_eth_bls_pubkey,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a signature in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_serialize_signature_compressed(
        dst: *mut byte,
        sig: *const ctt_eth_bls_signature,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a secret key\n  This also validates the secret key.\n\n  This is protected against side-channel unless your key is invalid.\n  In that case it will like whether it's all zeros or larger than the curve order."]
    pub fn ctt_eth_bls_deserialize_seckey(
        seckey: *mut ctt_eth_bls_seckey,
        src: *const byte,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a public key in compressed (Zcash) format.\n  This does not validate the public key.\n  It is intended for cases where public keys are stored in a trusted location\n  and validation can be cached.\n\n  Warning ⚠:\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_pubkey_compressed_unchecked(
        pubkey: *mut ctt_eth_bls_pubkey,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a public_key in compressed (Zcash) format.\n  This also validates the public key.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_pubkey_compressed(
        pubkey: *mut ctt_eth_bls_pubkey,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a signature in compressed (Zcash) format.\n  This does not validate the signature.\n  It is intended for cases where public keys are stored in a trusted location\n  and validation can be cached.\n\n  Warning ⚠:\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_signature_compressed_unchecked(
        sig: *mut ctt_eth_bls_signature,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a signature in compressed (Zcash) format.\n  This also validates the signature.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_signature_compressed(
        sig: *mut ctt_eth_bls_signature,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[doc = " Derive the public key matching with a secret key\n\n  Secret protection:\n  - A valid secret key will only leak that it is valid.\n  - An invalid secret key will leak whether it's all zero or larger than the curve order."]
    pub fn ctt_eth_bls_derive_pubkey(
        pubkey: *mut ctt_eth_bls_pubkey,
        seckey: *const ctt_eth_bls_seckey,
    );
}
extern "C" {
    #[doc = " Produce a signature for the message under the specified secret key\n  Signature is on BLS12-381 G2 (and public key on G1)\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - A secret key\n  - A message\n\n  Output:\n  - `signature` is overwritten with `message` signed with `secretKey`\n    with the scheme\n  - A status code indicating success or if the secret key is invalid.\n\n  Secret protection:\n  - A valid secret key will only leak that it is valid.\n  - An invalid secret key will leak whether it's all zero or larger than the curve order."]
    pub fn ctt_eth_bls_sign(
        sig: *mut ctt_eth_bls_signature,
        seckey: *const ctt_eth_bls_seckey,
        message: *const byte,
        message_len: usize,
    );
}
extern "C" {
    #[must_use]
    #[doc = " Check that a signature is valid for a message\n  under the provided public key.\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - A public key initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - A message\n  - A signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  Output:\n  - a status code with verification success if signature is valid\n    or indicating verification failure\n\n  In particular, the public key and signature are assumed to be on curve and subgroup-checked."]
    pub fn ctt_eth_bls_verify(
        pubkey: *const ctt_eth_bls_pubkey,
        message: *const byte,
        message_len: usize,
        sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
extern "C" {
    #[must_use]
    #[doc = " Check that a signature is valid for a message\n  under the aggregate of provided public keys.\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - A message\n  - A signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked."]
    pub fn ctt_eth_bls_fast_aggregate_verify(
        pubkeys: *const ctt_eth_bls_pubkey,
        pubkeys_len: usize,
        message: *const byte,
        message_len: usize,
        aggregate_sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify the aggregated signature of multiple (pubkey, message) pairs\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - Messages\n  - `len`: Number of elements in the `pubkeys` and `messages` arrays.\n  - a signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked.\n\n  To avoid splitting zeros and rogue keys attack:\n  1. Public keys signing the same message MUST be aggregated and checked for 0 before calling this function.\n  2. Augmentation or Proof of possessions must used for each public keys."]
    pub fn ctt_eth_bls_aggregate_verify(
        pubkeys: *const ctt_eth_bls_pubkey,
        messages: *const ctt_span,
        len: usize,
        aggregate_sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify that all (pubkey, message, signature) triplets are valid\n  returns `true` if all signatures are valid, `false` if at least one is invalid.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - Messages\n  - Signatures initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked.\n\n  To avoid splitting zeros and rogue keys attack:\n  1. Cryptographically-secure random bytes must be provided.\n  2. Augmentation or Proof of possessions must used for each public keys.\n\n  The secureRandomBytes will serve as input not under the attacker control to foil potential splitting zeros inputs.\n  The scheme assumes that the attacker cannot\n  resubmit 2^64 times forged (publickey, message, signature) triplets\n  against the same `secureRandomBytes`"]
    pub fn ctt_eth_bls_batch_verify(
        pubkeys: *const ctt_eth_bls_pubkey,
        messages: *const ctt_span,
        signatures: *const ctt_eth_bls_signature,
        len: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_bls_status;
}
extern "C" {
    #[doc = " Allocator function for the incomplete struct of the batch sig accumulator.\n Users of the C API *must* use this."]
    pub fn ctt_eth_bls_alloc_batch_sig_accumulator() -> *mut ctt_eth_bls_batch_sig_accumulator;
}
extern "C" {
    #[doc = " Function to free the storage allocated by the above.\n Users of the C API *must* use this."]
    pub fn ctt_eth_bls_free_batch_sig_accumulator(ptr: *mut ctt_eth_bls_batch_sig_accumulator);
}
extern "C" {
    #[doc = "  Initializes a Batch BLS Signature accumulator context.\n\n  This requires cryptographically secure random bytes\n  to defend against forged signatures that would not\n  verify individually but would verify while aggregated\n  https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407/14\n\n  An optional accumulator separation tag can be added\n  so that from a single source of randomness\n  each accumulatpr is seeded with a different state.\n  This is useful in multithreaded context."]
    pub fn ctt_eth_bls_init_batch_sig_accumulator(
        ctx: *mut ctt_eth_bls_batch_sig_accumulator,
        secure_random_bytes: *const byte,
        accum_sep_tag: *const byte,
        accum_sep_tag_len: usize,
    );
}
extern "C" {
    #[must_use]
    #[doc = "  Add a (public key, message, signature) triplet\n  to a BLS signature accumulator\n\n  Assumes that the public key and signature\n  have been group checked\n\n  Returns false if pubkey or signatures are the infinity points\n"]
    pub fn ctt_eth_bls_update_batch_sig_accumulator(
        ctx: *mut ctt_eth_bls_batch_sig_accumulator,
        pubkey: *const ctt_eth_bls_pubkey,
        message: *const byte,
        message_len: usize,
        signature: *const ctt_eth_bls_signature,
    ) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "  Finish batch and/or aggregate signature verification and returns the final result.\n\n  Returns false if nothing was accumulated\n  Rteturns false on verification failure"]
    pub fn ctt_eth_bls_final_verify_batch_sig_accumulator(
        ctx: *mut ctt_eth_bls_batch_sig_accumulator,
    ) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "  Verify that all (pubkey, message, signature) triplets are valid\n  returns `true` if all signatures are valid, `false` if at least one is invalid.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - Messages as an anonymous struct of `(data = byte*, length = size_t)` pairs\n    (the `View` type on the Nim side uses `int` for the length field, which depends on the\n    system)\n  - Signatures initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n  - `len`: number of elements in `pubkey`, `messages`, `sig` arrays\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked.\n\n  To avoid splitting zeros and rogue keys attack:\n  1. Cryptographically-secure random bytes must be provided.\n  2. Augmentation or Proof of possessions must used for each public keys.\n\n  The secureRandomBytes will serve as input not under the attacker control to foil potential splitting zeros inputs.\n  The scheme assumes that the attacker cannot\n  resubmit 2^64 times forged (publickey, message, signature) triplets\n  against the same `secureRandomBytes`"]
    pub fn ctt_eth_bls_batch_verify_parallel(
        tp: *const ctt_threadpool,
        pubkey: *const ctt_eth_bls_pubkey,
        messages: *const ctt_span,
        sig: *const ctt_eth_bls_signature,
        len: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_bls_status;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_context_struct {
    _unused: [u8; 0],
}
pub type ctt_eth_kzg_context = ctt_eth_kzg_context_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_commitment {
    raw: [byte; 48usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_commitment() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_commitment> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_commitment>(),
        48usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_commitment))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_commitment>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_commitment))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_commitment),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_proof {
    raw: [byte; 48usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_proof() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_proof> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_proof>(),
        48usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_proof))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_proof>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_proof))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_proof),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_blob {
    raw: [byte; 131072usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_blob() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_blob> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_blob>(),
        131072usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_blob))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_blob>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_blob))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_blob),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_opening_challenge {
    raw: [byte; 32usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_opening_challenge() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_opening_challenge> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_opening_challenge>(),
        32usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_opening_challenge))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_opening_challenge>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_opening_challenge))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_opening_challenge),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_eval_at_challenge {
    raw: [byte; 32usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_eval_at_challenge() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_eval_at_challenge> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_eval_at_challenge>(),
        32usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_eval_at_challenge))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_eval_at_challenge>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_eval_at_challenge))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_eval_at_challenge),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_kzg_status {
    cttEthKzg_Success = 0,
    cttEthKzg_VerificationFailure = 1,
    cttEthKzg_InputsLengthsMismatch = 2,
    cttEthKzg_ScalarZero = 3,
    cttEthKzg_ScalarLargerThanCurveOrder = 4,
    cttEthKzg_EccInvalidEncoding = 5,
    cttEthKzg_EccCoordinateGreaterThanOrEqualModulus = 6,
    cttEthKzg_EccPointNotOnCurve = 7,
    cttEthKzg_EccPointNotInSubgroup = 8,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_trusted_setup_status {
    cttEthTS_Success = 0,
    cttEthTS_MissingOrInaccessibleFile = 1,
    cttEthTS_InvalidFile = 2,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_trusted_setup_format {
    cttEthTSFormat_ckzg4844 = 0,
}
extern "C" {
    #[must_use]
    #[doc = " Compute a commitment to the `blob`.\n  The commitment can be verified without needing the full `blob`\n\n  Mathematical description\n    commitment = [p(τ)]₁\n\n    The blob data is used as a polynomial,\n    the polynomial is evaluated at powers of tau τ, a trusted setup.\n\n    Verification can be done by verifying the relation:\n      proof.(τ - z) = p(τ)-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at τ, p(τ) is the commitment\n    - and at the verification opening challenge z.\n\n    with proof = [(p(τ) - p(z)) / (τ-z)]₁"]
    pub fn ctt_eth_kzg_blob_to_kzg_commitment(
        ctx: *const ctt_eth_kzg_context,
        dst: *mut ctt_eth_kzg_commitment,
        blob: *const ctt_eth_kzg_blob,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Generate:\n  - A proof of correct evaluation.\n  - y = p(z), the evaluation of p at the opening challenge z, with p being the Blob interpreted as a polynomial.\n\n  Mathematical description\n    [proof]₁ = [(p(τ) - p(z)) / (τ-z)]₁, with p(τ) being the commitment, i.e. the evaluation of p at the powers of τ\n    The notation [a]₁ corresponds to the scalar multiplication of a by the generator of 𝔾1\n\n    Verification can be done by verifying the relation:\n      proof.(τ - z) = p(τ)-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at τ, p(τ) is the commitment\n    - and at the verification opening challenge z."]
    pub fn ctt_eth_kzg_compute_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        y: *mut ctt_eth_kzg_eval_at_challenge,
        blob: *const ctt_eth_kzg_blob,
        z: *const ctt_eth_kzg_opening_challenge,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify KZG proof\n  that p(z) == y where\n    - z is a random opening_challenge\n    - y is the evaluation of the \"KZG polynomial\" p at z\n    - commitment is p(τ), the evaluation of p at the trusted setup τ,\n    - [proof]₁ = [(p(τ) - p(z)) / (τ-z)]₁, ensure that p(z) evaluation was correct\n      without needing access to the polynomial p itself."]
    pub fn ctt_eth_kzg_verify_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        commitment: *const ctt_eth_kzg_commitment,
        z: *const ctt_eth_kzg_opening_challenge,
        y: *const ctt_eth_kzg_eval_at_challenge,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob, return the KZG proof that is used to verify it against the commitment.\n  This method does not verify that the commitment is correct with respect to `blob`."]
    pub fn ctt_eth_kzg_compute_blob_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob and a KZG proof, verify that the blob data corresponds to the provided commitment."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify `n` (blob, commitment, proof) sets efficiently\n\n  `n` is the number of verifications set\n  - if n is negative, this procedure returns verification failure\n  - if n is zero, this procedure returns verification success\n\n  `secure_random_bytes` random bytes must come from a cryptographically secure RNG\n  or computed through the Fiat-Shamir heuristic.\n  It serves as a random number\n  that is not in the control of a potential attacker to prevent potential\n  rogue commitments attacks due to homomorphic properties of pairings,\n  i.e. commitments that are linear combination of others and sum would be zero."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_batch(
        ctx: *const ctt_eth_kzg_context,
        blobs: *const ctt_eth_kzg_blob,
        commitments: *const ctt_eth_kzg_commitment,
        proofs: *const ctt_eth_kzg_proof,
        n: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Load trusted setup from path\n  Currently the only format supported `cttEthTSFormat_ckzg4844`\n  is from the reference implementation c-kzg-4844 text file"]
    pub fn ctt_eth_trusted_setup_load(
        ctx: *mut *mut ctt_eth_kzg_context,
        filepath: *const ::core::ffi::c_char,
        format: ctt_eth_trusted_setup_format,
    ) -> ctt_eth_trusted_setup_status;
}
extern "C" {
    #[doc = " Destroy a trusted setup"]
    pub fn ctt_eth_trusted_setup_delete(ctx: *mut ctt_eth_kzg_context);
}
extern "C" {
    #[must_use]
    #[doc = " Compute a commitment to the `blob`.\n  The commitment can be verified without needing the full `blob`\n\n  Mathematical description\n    commitment = [p(τ)]₁\n\n    The blob data is used as a polynomial,\n    the polynomial is evaluated at powers of tau τ, a trusted setup.\n\n    Verification can be done by verifying the relation:\n      proof.(τ - z) = p(τ)-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at τ, p(τ) is the commitment\n    - and at the verification opening_challenge z.\n\n    with proof = [(p(τ) - p(z)) / (τ-z)]₁"]
    pub fn ctt_eth_kzg_blob_to_kzg_commitment_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        dst: *mut ctt_eth_kzg_commitment,
        blob: *const ctt_eth_kzg_blob,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Generate:\n  - A proof of correct evaluation.\n  - y = p(z), the evaluation of p at the opening_challenge z, with p being the Blob interpreted as a polynomial.\n\n  Mathematical description\n    [proof]₁ = [(p(τ) - p(z)) / (τ-z)]₁, with p(τ) being the commitment, i.e. the evaluation of p at the powers of τ\n    The notation [a]₁ corresponds to the scalar multiplication of a by the generator of 𝔾1\n\n    Verification can be done by verifying the relation:\n      proof.(τ - z) = p(τ)-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at τ, p(τ) is the commitment\n    - and at the verification opening_challenge z."]
    pub fn ctt_eth_kzg_compute_kzg_proof_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        y: *mut ctt_eth_kzg_eval_at_challenge,
        blob: *const ctt_eth_kzg_blob,
        z: *const ctt_eth_kzg_opening_challenge,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob, return the KZG proof that is used to verify it against the commitment.\n  This method does not verify that the commitment is correct with respect to `blob`."]
    pub fn ctt_eth_kzg_compute_blob_kzg_proof_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob and a KZG proof, verify that the blob data corresponds to the provided commitment."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify `n` (blob, commitment, proof) sets efficiently\n\n  `n` is the number of verifications set\n  - if n is negative, this procedure returns verification failure\n  - if n is zero, this procedure returns verification success\n\n  `secure_random_bytes` random bytes must come from a cryptographically secure RNG\n  or computed through the Fiat-Shamir heuristic.\n  It serves as a random number\n  that is not in the control of a potential attacker to prevent potential\n  rogue commitments attacks due to homomorphic properties of pairings,\n  i.e. commitments that are linear combination of others and sum would be zero."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_batch_parallel(
        tp: *const ctt_threadpool,
        ctx: *const ctt_eth_kzg_context,
        blobs: *const ctt_eth_kzg_blob,
        commitments: *const ctt_eth_kzg_commitment,
        proofs: *const ctt_eth_kzg_proof,
        n: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_kzg_status;
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_evm_status {
    cttEVM_Success = 0,
    cttEVM_InvalidInputSize = 1,
    cttEVM_InvalidOutputSize = 2,
    cttEVM_IntLargerThanModulus = 3,
    cttEVM_PointNotOnCurve = 4,
    cttEVM_PointNotInSubgroup = 5,
}
extern "C" {
    #[must_use]
    #[doc = "  SHA256\n\n  Inputs:\n  - r: array with 32 bytes of storage for the result\n  - r_len: length of `r`. Must be 32\n  - inputs: Message to hash\n  - inputs_len: length of the inputs array\n\n  Output:\n  - 32-byte digest\n  - status code:\n    cttEVM_Success\n    cttEVM_InvalidOutputSize"]
    pub fn ctt_eth_evm_sha256(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Helper for `eth_evm_modexp`. Returns the size required to be allocated based on the\n  given input. Call this function first, then allocate space for the result buffer\n  in the call to `eth_evm_modexp` based on this function's result.\n\n  The size depends on the `modulusLen`, which is the third 32 bytes,\n  `inputs == [baseLen { 32 bytes }, exponentLen { 32 bytes }, modulusLen { 32 bytes }, ... ]`\n  in `inputs`.\n\n  The associated modulus length in bytes is the size required by the\n  result to `eth_evm_modexp`."]
    pub fn ctt_eth_evm_modexp_result_size(
        size: *mut u64,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Modular exponentiation\n\n  Name: MODEXP\n\n  Inputs:\n  - `baseLen`:     32 bytes base integer length (in bytes)\n  - `exponentLen`: 32 bytes exponent length (in bytes)\n  - `modulusLen`:  32 bytes modulus length (in bytes)\n  - `base`:        base integer (`baseLen` bytes)\n  - `exponent`:    exponent (`exponentLen` bytes)\n  - `modulus`:     modulus (`modulusLen` bytes)\n\n  Output:\n  - baseᵉˣᵖᵒⁿᵉⁿᵗ (mod modulus)\n    The result buffer size `r` MUST match the modulusLen\n  - status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize if the lengths require more than 32-bit or 64-bit addressing (depending on hardware)\n    cttEVM_InvalidOutputSize\n\n  Spec\n    Yellow Paper Appendix E\n    EIP-198 - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-198.md\n\n  Hardware considerations:\n    This procedure stack allocates a table of (16+1)*modulusLen and many stack temporaries.\n    Make sure to validate gas costs and reject large inputs to bound stack usage."]
    pub fn ctt_eth_evm_modexp(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BN254_Snarks\n  (also called alt_bn128 in Ethereum specs\n   and bn256 in Ethereum tests)\n\n  Name: ECADD\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A G1 point Q with coordinates (Qx, Qy)\n\n  Each coordinate is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, Qx, Qy]\n  If the length is less than 128 bytes, input is virtually padded with zeros.\n  If the length is greater than 128 bytes, input is truncated to 128 bytes.\n\n  Output\n  - Output buffer MUST be of length 64 bytes\n  - A G1 point R = P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-196"]
    pub fn ctt_eth_evm_bn254_g1add(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve multiplication on BN254_Snarks\n  (also called alt_bn128 in Ethereum specs\n   and bn256 in Ethereum tests)\n\n  Name: ECMUL\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A scalar s in 0 ..< 2²⁵⁶\n\n  Each coordinate is a 32-byte bigEndian integer\n  r is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, r]\n  If the length is less than 96 bytes, input is virtually padded with zeros.\n  If the length is greater than 96 bytes, input is truncated to 96 bytes.\n\n  Output\n  - Output buffer MUST be of length 64 bytes\n  - A G1 point R = [s]P\n  - Status codes:\n    cttEVM_Success\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-196"]
    pub fn ctt_eth_evm_bn254_g1mul(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve pairing check on BN254_Snarks\n  (also called alt_bn128 in Ethereum specs\n   and bn256 in Ethereum tests)\n\n  Name: ECPAIRING / Pairing check\n\n  Inputs:\n  - An array of [(P0, Q0), (P1, Q1), ... (Pk, Qk)] points in (G1, G2)\n\n  Output\n  - Output buffer MUST be of length 32 bytes\n  - 0 or 1 in uint256 BigEndian representation\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n    cttEVM_PointNotInSubgroup\n\n  Specs https://eips.ethereum.org/EIPS/eip-197\n        https://eips.ethereum.org/EIPS/eip-1108"]
    pub fn ctt_eth_evm_bn254_ecpairingcheck(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G1\n\n  Name: BLS12_G1ADD\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A G1 point Q with coordinates (Qx, Qy)\n  - Input buffer MUST be 256 bytes\n\n  Each coordinate is a 64-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, Qx, Qy]\n\n  Inputs are NOT subgroup-checked.\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G1 point R=P+Q with coordinates (Rx, Ry)\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g1add(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G2\n\n  Name: BLS12_G2ADD\n\n  Inputs:\n  - A G2 point P with coordinates (Px, Py)\n  - A G2 point Q with coordinates (Qx, Qy)\n  - Input buffer MUST be 512 bytes\n\n  Each coordinate is a 128-byte bigEndian integer pair (a+𝑖b) with 𝑖 = √-1\n  They are serialized concatenated in a byte array [Px, Py, Qx, Qy]\n\n  Inputs are NOT subgroup-checked.\n\n  Output\n  - Output buffer MUST be of length 256 bytes\n  - A G2 point R=P+Q with coordinates (Rx, Ry)\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g2add(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve scalar multiplication on BLS12-381 G1\n\n  Name: BLS12_G1MUL\n\n  Inputs:\n  - A G1 point P with coordinates (Px, Py)\n  - A scalar s in 0 ..< 2²⁵⁶\n  - Input buffer MUST be 160 bytes\n\n  Each coordinate is a 64-byte bigEndian integer\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, s]\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G1 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g1mul(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve scalar multiplication on BLS12-381 G2\n\n  Name: BLS12_G2MUL\n\n  Inputs:\n  - A G2 point P with coordinates (Px, Py)\n  - A scalar s in 0 ..< 2²⁵⁶\n  - Input buffer MUST be 288 bytes\n\n  Each coordinate is a 128-byte bigEndian integer pair (a+𝑖b) with 𝑖 = √-1\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [Px, Py, s]\n\n  Output\n  - Output buffer MUST be of length 256 bytes\n  - A G2 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g2mul(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G1\n\n  Name: BLS12_G1MSM\n\n  Inputs:\n  - A sequence of pairs of points\n    - G1 points Pᵢ with coordinates (Pᵢx, Pᵢy)\n    - scalar sᵢ in 0 ..< 2²⁵⁶\n  - Each pair MUST be 160 bytes\n  - The total length MUST be a multiple of 160 bytes\n\n  Each coordinate is a 64-byte bigEndian integer\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [(P₀x, P₀y, r₀), (P₁x, P₁y, r₁) ..., (Pₙx, Pₙy, rₙ)]\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G1 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g1msm(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic Curve addition on BLS12-381 G2\n\n  Name: BLS12_G2MSM\n\n  Inputs:\n  - A sequence of pairs of points\n    - G2 points Pᵢ with coordinates (Pᵢx, Pᵢy)\n    - scalar sᵢ in 0 ..< 2²⁵⁶\n  - Each pair MUST be 288 bytes\n  - The total length MUST be a multiple of 288 bytes\n\n  Each coordinate is a 128-byte bigEndian integer pair (a+𝑖b) with 𝑖 = √-1\n  s is a 32-byte bigEndian integer\n  They are serialized concatenated in a byte array [(P₀x, P₀y, r₀), (P₁x, P₁y, r₁) ..., (Pₙx, Pₙy, rₙ)]\n\n  Output\n  - Output buffer MUST be of length 512 bytes\n  - A G2 point R=P+Q with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_g2msm(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Elliptic curve pairing check on BLS12-381\n\n  Name: BLS12_PAIRINGCHECK\n\n  Inputs:\n  - An array of [(P0, Q0), (P1, Q1), ... (Pk, Qk)] points in (G1, G2)\n\n  Output\n  - Output buffer MUST be of length 32 bytes\n  - 0 or 1 in uint256 BigEndian representation\n  - Status codes:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n    cttEVM_PointNotOnCurve\n    cttEVM_PointNotInSubgroup\n\n  specs https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_pairingcheck(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Map a field element to G1\n\n  Name: BLS12_MAP_FP_TO_G1\n\n  Input:\n  - A field element in 0 ..< p, p the prime field of BLS12-381\n  - The length MUST be a 48-byte (381-bit) number serialized in 64-byte big-endian number\n\n  Output\n  - Output buffer MUST be of length 64 bytes\n  - A G1 point R with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_map_fp_to_g1(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
extern "C" {
    #[must_use]
    #[doc = "  Map an Fp2 extension field element to G2\n\n  Name: BLS12_MAP_FP2_TO_G2\n\n  Input:\n  - An extension field element in (0, 0) ..< (p, p), p the prime field of BLS12-381\n  - The length MUST be a tuple of 48-byte (381-bit) number serialized in tuple of 64-byte big-endian numbers\n\n  Output\n  - Output buffer MUST be of length 128 bytes\n  - A G2 point R with coordinates (Rx, Ry)\n  - Status code:\n    cttEVM_Success\n    cttEVM_InvalidInputSize\n    cttEVM_InvalidOutputSize\n    cttEVM_IntLargerThanModulus\n\n  Spec https://eips.ethereum.org/EIPS/eip-2537"]
    pub fn ctt_eth_evm_bls12381_map_fp2_to_g2(
        r: *mut byte,
        r_len: usize,
        inputs: *const byte,
        inputs_len: usize,
    ) -> ctt_evm_status;
}
