/* automatically generated by rust-bindgen 0.69.1 */

pub type secret_word = usize;
pub type secret_bool = usize;
pub type byte = u8;
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_codec_scalar_status {
    cttCodecScalar_Success = 0,
    cttCodecScalar_Zero = 1,
    cttCodecScalar_ScalarLargerThanCurveOrder = 2,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_codec_ecc_status {
    cttCodecEcc_Success = 0,
    cttCodecEcc_InvalidEncoding = 1,
    cttCodecEcc_CoordinateGreaterThanOrEqualModulus = 2,
    cttCodecEcc_PointNotOnCurve = 3,
    cttCodecEcc_PointNotInSubgroup = 4,
    cttCodecEcc_PointAtInfinity = 5,
}
#[repr(C)]
#[derive(Debug)]
pub struct ctt_threadpool {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new threadpool that manages `num_threads` threads\n\n Initialize a threadpool that manages `num_threads` threads.\n\n A threadpool uses thread-local storage and (for external consumers)\n MUST be used from the thread that instantiated it.\n\n In particular, this means that:\n - runtime.LockOSThread() is needed from Go to avoid it allocating CGO calls to a new thread.\n - The threadpool cannot be ``Send`` in Rust or ``Clone`` (we can't deep-copy threads)\n\n 2 threadpools MUST NOT be instantiated at the same time from the same thread.\n\n Mixing with other libraries' threadpools and runtime\n will not impact correctness but may impact performance.\n"]
    pub fn ctt_threadpool_new(num_threads: ::core::ffi::c_int) -> *mut ctt_threadpool;
}
extern "C" {
    #[doc = " Wait until all pending tasks are processed and then shutdown the threadpool"]
    pub fn ctt_threadpool_shutdown(threadpool: *mut ctt_threadpool);
}
extern "C" {
    #[doc = " Query the number of threads available at the OS-level\n  to run computations.\n\n  This takes into account cores disabled at the OS-level, for example in a VM.\n  However this doesn't detect restrictions based on time quotas often used for Docker\n  or taskset / cpuset restrictions from cgroups.\n\n  For Simultaneous-Multithreading (SMT often call HyperThreading),\n  this returns the number of available logical cores."]
    pub fn ctt_cpu_get_num_threads_os() -> ::core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct ctt_sha256_context {
    message_schedule: [u32; 16usize],
    buf: [byte; 64usize],
    msgLen: u64,
}
#[test]
fn bindgen_test_layout_ctt_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_sha256_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_sha256_context>(),
        192usize,
        concat!("Size of: ", stringify!(ctt_sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_sha256_context>(),
        64usize,
        concat!("Alignment of ", stringify!(ctt_sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message_schedule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_sha256_context),
            "::",
            stringify!(message_schedule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_sha256_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msgLen) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_sha256_context),
            "::",
            stringify!(msgLen)
        )
    );
}
extern "C" {
    #[doc = " Initialize or reinitialize a Sha256 context."]
    pub fn ctt_sha256_init(ctx: *mut ctt_sha256_context);
}
extern "C" {
    #[doc = " Append a message to a SHA256 context\n  for incremental SHA256 computation\n\n  Security note: the tail of your message might be stored\n  in an internal buffer.\n  if sensitive content is used, ensure that\n  `ctx.finish(...)` and `ctx.clear()` are called as soon as possible.\n  Additionally ensure that the message(s) passed were stored\n  in memory considered secure for your threat model.\n\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_update(
        ctx: *mut ctt_sha256_context,
        message: *const byte,
        message_len: isize,
    );
}
extern "C" {
    #[doc = " Finalize a SHA256 computation and output the\n  message digest to the `digest` buffer.\n\n  Security note: this does not clear the internal buffer.\n  if sensitive content is used, use \"ctx.clear()\"\n  and also make sure that the message(s) passed were stored\n  in memory considered secure for your threat model.\n\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_finish(ctx: *mut ctt_sha256_context, digest: *mut byte);
}
extern "C" {
    #[doc = " Clear the context internal buffers\n  Security note:\n  For passwords and secret keys, you MUST NOT use raw SHA-256\n  use a Key Derivation Function instead (KDF)"]
    pub fn ctt_sha256_clear(ctx: *mut ctt_sha256_context);
}
extern "C" {
    #[doc = " Compute the SHA-256 hash of message\n  and store the result in digest.\n  Optionally, clear the memory buffer used."]
    pub fn ctt_sha256_hash(
        digest: *mut byte,
        message: *const byte,
        message_len: isize,
        clear_memory: bool,
    );
}
extern "C" {
    pub fn ctt_csprng_sysrand(buffer: *mut ::core::ffi::c_void, len: usize) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_fr {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_bls12_381_fr() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_fr>(),
        32usize,
        concat!("Size of: ", stringify!(bls12_381_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_fr>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_fp {
    limbs: [secret_word; 6usize],
}
#[test]
fn bindgen_test_layout_bls12_381_fp() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_fp>(),
        48usize,
        concat!("Size of: ", stringify!(bls12_381_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_fp>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_fp2 {
    c: [bls12_381_fp; 2usize],
}
#[test]
fn bindgen_test_layout_bls12_381_fp2() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_fp2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_fp2>(),
        96usize,
        concat!("Size of: ", stringify!(bls12_381_fp2))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_fp2>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_fp2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_fp2),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g1_aff {
    x: bls12_381_fp,
    y: bls12_381_fp,
}
#[test]
fn bindgen_test_layout_bls12_381_g1_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g1_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g1_aff>(),
        96usize,
        concat!("Size of: ", stringify!(bls12_381_g1_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g1_aff>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_g1_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g1_jac {
    x: bls12_381_fp,
    y: bls12_381_fp,
    z: bls12_381_fp,
}
#[test]
fn bindgen_test_layout_bls12_381_g1_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g1_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g1_jac>(),
        144usize,
        concat!("Size of: ", stringify!(bls12_381_g1_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g1_jac>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_g1_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g1_prj {
    x: bls12_381_fp,
    y: bls12_381_fp,
    z: bls12_381_fp,
}
#[test]
fn bindgen_test_layout_bls12_381_g1_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g1_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g1_prj>(),
        144usize,
        concat!("Size of: ", stringify!(bls12_381_g1_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g1_prj>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_g1_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g1_prj),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g2_aff {
    x: bls12_381_fp2,
    y: bls12_381_fp2,
}
#[test]
fn bindgen_test_layout_bls12_381_g2_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g2_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g2_aff>(),
        192usize,
        concat!("Size of: ", stringify!(bls12_381_g2_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g2_aff>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_g2_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g2_jac {
    x: bls12_381_fp2,
    y: bls12_381_fp2,
    z: bls12_381_fp2,
}
#[test]
fn bindgen_test_layout_bls12_381_g2_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g2_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g2_jac>(),
        288usize,
        concat!("Size of: ", stringify!(bls12_381_g2_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g2_jac>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_g2_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bls12_381_g2_prj {
    x: bls12_381_fp2,
    y: bls12_381_fp2,
    z: bls12_381_fp2,
}
#[test]
fn bindgen_test_layout_bls12_381_g2_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bls12_381_g2_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bls12_381_g2_prj>(),
        288usize,
        concat!("Size of: ", stringify!(bls12_381_g2_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bls12_381_g2_prj>(),
        8usize,
        concat!("Alignment of ", stringify!(bls12_381_g2_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bls12_381_g2_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fr_unmarshalBE(
        dst: *mut bls12_381_fr,
        src: *const byte,
        src_len: isize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fr_marshalBE(
        dst: *mut byte,
        dst_len: isize,
        src: *const bls12_381_fr,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_eq(a: *const bls12_381_fr, b: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_zero(a: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_one(a: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_is_minus_one(a: *const bls12_381_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fr_set_zero(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_set_one(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_set_minus_one(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_neg(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_neg_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_sum(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_add_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_diff(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_sub_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_double(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_double_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_prod(
        r: *mut bls12_381_fr,
        a: *const bls12_381_fr,
        b: *const bls12_381_fr,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_mul_in_place(a: *mut bls12_381_fr, b: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_square(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_square_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_div2(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_inv(r: *mut bls12_381_fr, a: *const bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_inv_in_place(a: *mut bls12_381_fr);
}
extern "C" {
    pub fn ctt_bls12_381_fr_ccopy(a: *mut bls12_381_fr, b: *const bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cswap(a: *mut bls12_381_fr, b: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cset_zero(a: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cset_one(a: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cneg_in_place(a: *mut bls12_381_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fr_cadd_in_place(
        a: *mut bls12_381_fr,
        b: *const bls12_381_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fr_csub_in_place(
        a: *mut bls12_381_fr,
        b: *const bls12_381_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fp_unmarshalBE(
        dst: *mut bls12_381_fp,
        src: *const byte,
        src_len: isize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bls12_381_fp_marshalBE(
        dst: *mut byte,
        dst_len: isize,
        src: *const bls12_381_fp,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_eq(a: *const bls12_381_fp, b: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_zero(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_one(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_minus_one(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_set_zero(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_set_one(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_set_minus_one(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_neg(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_neg_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_sum(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_add_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_diff(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_sub_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_double(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_double_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_prod(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
        b: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_mul_in_place(a: *mut bls12_381_fp, b: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_square(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_square_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_div2(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_inv(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_inv_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_ccopy(a: *mut bls12_381_fp, b: *const bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cswap(a: *mut bls12_381_fp, b: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cset_zero(a: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cset_one(a: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cneg_in_place(a: *mut bls12_381_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp_cadd_in_place(
        a: *mut bls12_381_fp,
        b: *const bls12_381_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_csub_in_place(
        a: *mut bls12_381_fp,
        b: *const bls12_381_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_is_square(a: *const bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_invsqrt(r: *mut bls12_381_fp, a: *const bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_invsqrt_in_place(
        r: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_in_place(a: *mut bls12_381_fp);
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_if_square_in_place(a: *mut bls12_381_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_invsqrt(
        sqrt: *mut bls12_381_fp,
        invsqrt: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_invsqrt_if_square(
        sqrt: *mut bls12_381_fp,
        invsqrt: *mut bls12_381_fp,
        a: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp_sqrt_ratio_if_square(
        r: *mut bls12_381_fp,
        u: *const bls12_381_fp,
        v: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_eq(a: *const bls12_381_fp2, b: *const bls12_381_fp2)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_zero(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_one(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_minus_one(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_set_zero(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_set_one(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_set_minus_one(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_neg(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sum(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_add_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_diff(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sub_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_double(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_double_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conj(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conj_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conjneg(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_conjneg_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_prod(
        r: *mut bls12_381_fp2,
        a: *const bls12_381_fp2,
        b: *const bls12_381_fp2,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_mul_in_place(a: *mut bls12_381_fp2, b: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_square(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_square_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_div2(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_inv(r: *mut bls12_381_fp2, a: *const bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_inv_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_ccopy(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cset_zero(a: *mut bls12_381_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cset_one(a: *mut bls12_381_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cneg_in_place(a: *mut bls12_381_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_cadd_in_place(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_csub_in_place(
        a: *mut bls12_381_fp2,
        b: *const bls12_381_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_fp2_is_square(a: *const bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sqrt_in_place(a: *mut bls12_381_fp2);
}
extern "C" {
    pub fn ctt_bls12_381_fp2_sqrt_if_square_in_place(a: *mut bls12_381_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_eq(
        P: *const bls12_381_g1_aff,
        Q: *const bls12_381_g1_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_inf(P: *const bls12_381_g1_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_set_inf(P: *mut bls12_381_g1_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_ccopy(
        P: *mut bls12_381_g1_aff,
        Q: *const bls12_381_g1_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_is_on_curve(
        x: *const bls12_381_fp,
        y: *const bls12_381_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_neg(P: *mut bls12_381_g1_aff, Q: *const bls12_381_g1_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g1_aff_neg_in_place(P: *mut bls12_381_g1_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_is_eq(
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_is_inf(P: *const bls12_381_g1_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_set_inf(P: *mut bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_ccopy(
        P: *mut bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_neg(P: *mut bls12_381_g1_jac, Q: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_neg_in_place(P: *mut bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_cneg_in_place(P: *mut bls12_381_g1_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_sum(
        r: *mut bls12_381_g1_jac,
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_add_in_place(P: *mut bls12_381_g1_jac, Q: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_diff(
        r: *mut bls12_381_g1_jac,
        P: *const bls12_381_g1_jac,
        Q: *const bls12_381_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_double(r: *mut bls12_381_g1_jac, P: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_double_in_place(P: *mut bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_affine(dst: *mut bls12_381_g1_aff, src: *const bls12_381_g1_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_from_affine(
        dst: *mut bls12_381_g1_jac,
        src: *const bls12_381_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_is_eq(
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_is_inf(P: *const bls12_381_g1_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_set_inf(P: *mut bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_ccopy(
        P: *mut bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_neg(P: *mut bls12_381_g1_prj, Q: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_neg_in_place(P: *mut bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_cneg_in_place(P: *mut bls12_381_g1_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_sum(
        r: *mut bls12_381_g1_prj,
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_add_in_place(P: *mut bls12_381_g1_prj, Q: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_diff(
        r: *mut bls12_381_g1_prj,
        P: *const bls12_381_g1_prj,
        Q: *const bls12_381_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_double(r: *mut bls12_381_g1_prj, P: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_double_in_place(P: *mut bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_affine(dst: *mut bls12_381_g1_aff, src: *const bls12_381_g1_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_from_affine(
        dst: *mut bls12_381_g1_prj,
        src: *const bls12_381_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_eq(
        P: *const bls12_381_g2_aff,
        Q: *const bls12_381_g2_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_inf(P: *const bls12_381_g2_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_set_inf(P: *mut bls12_381_g2_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_ccopy(
        P: *mut bls12_381_g2_aff,
        Q: *const bls12_381_g2_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_is_on_curve(
        x: *const bls12_381_fp2,
        y: *const bls12_381_fp2,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_neg(P: *mut bls12_381_g2_aff, Q: *const bls12_381_g2_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g2_aff_neg_in_place(P: *mut bls12_381_g2_aff);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_is_eq(
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_is_inf(P: *const bls12_381_g2_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_set_inf(P: *mut bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_ccopy(
        P: *mut bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_neg(P: *mut bls12_381_g2_jac, Q: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_neg_in_place(P: *mut bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_cneg_in_place(P: *mut bls12_381_g2_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_sum(
        r: *mut bls12_381_g2_jac,
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_add_in_place(P: *mut bls12_381_g2_jac, Q: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_diff(
        r: *mut bls12_381_g2_jac,
        P: *const bls12_381_g2_jac,
        Q: *const bls12_381_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_double(r: *mut bls12_381_g2_jac, P: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_double_in_place(P: *mut bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_affine(dst: *mut bls12_381_g2_aff, src: *const bls12_381_g2_jac);
}
extern "C" {
    pub fn ctt_bls12_381_g2_jac_from_affine(
        dst: *mut bls12_381_g2_jac,
        src: *const bls12_381_g2_aff,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_is_eq(
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_is_inf(P: *const bls12_381_g2_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_set_inf(P: *mut bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_ccopy(
        P: *mut bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_neg(P: *mut bls12_381_g2_prj, Q: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_neg_in_place(P: *mut bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_cneg_in_place(P: *mut bls12_381_g2_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_sum(
        r: *mut bls12_381_g2_prj,
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_add_in_place(P: *mut bls12_381_g2_prj, Q: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_diff(
        r: *mut bls12_381_g2_prj,
        P: *const bls12_381_g2_prj,
        Q: *const bls12_381_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_double(r: *mut bls12_381_g2_prj, P: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_double_in_place(P: *mut bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_affine(dst: *mut bls12_381_g2_aff, src: *const bls12_381_g2_prj);
}
extern "C" {
    pub fn ctt_bls12_381_g2_prj_from_affine(
        dst: *mut bls12_381_g2_prj,
        src: *const bls12_381_g2_aff,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_fr {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_bn254_snarks_fr() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_fr>(),
        32usize,
        concat!("Size of: ", stringify!(bn254_snarks_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_fr>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_fp {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_bn254_snarks_fp() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_fp>(),
        32usize,
        concat!("Size of: ", stringify!(bn254_snarks_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_fp>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_fp2 {
    c: [bn254_snarks_fp; 2usize],
}
#[test]
fn bindgen_test_layout_bn254_snarks_fp2() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_fp2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_fp2>(),
        64usize,
        concat!("Size of: ", stringify!(bn254_snarks_fp2))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_fp2>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_fp2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_fp2),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g1_aff {
    x: bn254_snarks_fp,
    y: bn254_snarks_fp,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g1_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g1_aff> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g1_aff>(),
        64usize,
        concat!("Size of: ", stringify!(bn254_snarks_g1_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g1_aff>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g1_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g1_jac {
    x: bn254_snarks_fp,
    y: bn254_snarks_fp,
    z: bn254_snarks_fp,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g1_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g1_jac> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g1_jac>(),
        96usize,
        concat!("Size of: ", stringify!(bn254_snarks_g1_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g1_jac>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g1_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g1_prj {
    x: bn254_snarks_fp,
    y: bn254_snarks_fp,
    z: bn254_snarks_fp,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g1_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g1_prj> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g1_prj>(),
        96usize,
        concat!("Size of: ", stringify!(bn254_snarks_g1_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g1_prj>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g1_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g1_prj),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g2_aff {
    x: bn254_snarks_fp2,
    y: bn254_snarks_fp2,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g2_aff() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g2_aff> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g2_aff>(),
        128usize,
        concat!("Size of: ", stringify!(bn254_snarks_g2_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g2_aff>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g2_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g2_jac {
    x: bn254_snarks_fp2,
    y: bn254_snarks_fp2,
    z: bn254_snarks_fp2,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g2_jac() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g2_jac> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g2_jac>(),
        192usize,
        concat!("Size of: ", stringify!(bn254_snarks_g2_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g2_jac>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g2_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn254_snarks_g2_prj {
    x: bn254_snarks_fp2,
    y: bn254_snarks_fp2,
    z: bn254_snarks_fp2,
}
#[test]
fn bindgen_test_layout_bn254_snarks_g2_prj() {
    const UNINIT: ::core::mem::MaybeUninit<bn254_snarks_g2_prj> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bn254_snarks_g2_prj>(),
        192usize,
        concat!("Size of: ", stringify!(bn254_snarks_g2_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<bn254_snarks_g2_prj>(),
        8usize,
        concat!("Alignment of ", stringify!(bn254_snarks_g2_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bn254_snarks_g2_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fr_unmarshalBE(
        dst: *mut bn254_snarks_fr,
        src: *const byte,
        src_len: isize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fr_marshalBE(
        dst: *mut byte,
        dst_len: isize,
        src: *const bn254_snarks_fr,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_eq(
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_zero(a: *const bn254_snarks_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_one(a: *const bn254_snarks_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_is_minus_one(a: *const bn254_snarks_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_set_zero(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_set_one(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_set_minus_one(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_neg(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_neg_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_sum(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_add_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_diff(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_sub_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_double(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_double_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_prod(
        r: *mut bn254_snarks_fr,
        a: *const bn254_snarks_fr,
        b: *const bn254_snarks_fr,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_mul_in_place(a: *mut bn254_snarks_fr, b: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_square(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_square_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_div2(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_inv(r: *mut bn254_snarks_fr, a: *const bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_inv_in_place(a: *mut bn254_snarks_fr);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_ccopy(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cswap(
        a: *mut bn254_snarks_fr,
        b: *mut bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cset_zero(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cset_one(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cneg_in_place(a: *mut bn254_snarks_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_cadd_in_place(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fr_csub_in_place(
        a: *mut bn254_snarks_fr,
        b: *const bn254_snarks_fr,
        ctl: secret_bool,
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fp_unmarshalBE(
        dst: *mut bn254_snarks_fp,
        src: *const byte,
        src_len: isize,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_bn254_snarks_fp_marshalBE(
        dst: *mut byte,
        dst_len: isize,
        src: *const bn254_snarks_fp,
    ) -> bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_eq(
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_zero(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_one(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_minus_one(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_set_zero(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_set_one(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_set_minus_one(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_neg(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_neg_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sum(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_add_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_diff(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sub_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_double(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_double_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_prod(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
        b: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_mul_in_place(a: *mut bn254_snarks_fp, b: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_square(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_square_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_div2(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_inv(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_inv_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_ccopy(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cswap(
        a: *mut bn254_snarks_fp,
        b: *mut bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cset_zero(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cset_one(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cneg_in_place(a: *mut bn254_snarks_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_cadd_in_place(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_csub_in_place(
        a: *mut bn254_snarks_fp,
        b: *const bn254_snarks_fp,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_is_square(a: *const bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_invsqrt(r: *mut bn254_snarks_fp, a: *const bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_invsqrt_in_place(
        r: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_in_place(a: *mut bn254_snarks_fp);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_if_square_in_place(a: *mut bn254_snarks_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_invsqrt(
        sqrt: *mut bn254_snarks_fp,
        invsqrt: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_invsqrt_if_square(
        sqrt: *mut bn254_snarks_fp,
        invsqrt: *mut bn254_snarks_fp,
        a: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp_sqrt_ratio_if_square(
        r: *mut bn254_snarks_fp,
        u: *const bn254_snarks_fp,
        v: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_eq(
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_zero(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_one(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_minus_one(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_zero(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_one(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_set_minus_one(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_neg(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sum(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_add_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_diff(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sub_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_double(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_double_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conj(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conj_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conjneg(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_conjneg_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_prod(
        r: *mut bn254_snarks_fp2,
        a: *const bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_mul_in_place(a: *mut bn254_snarks_fp2, b: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_square(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_square_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_div2(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_inv(r: *mut bn254_snarks_fp2, a: *const bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_inv_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_ccopy(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cset_zero(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cset_one(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cneg_in_place(a: *mut bn254_snarks_fp2, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_cadd_in_place(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_csub_in_place(
        a: *mut bn254_snarks_fp2,
        b: *const bn254_snarks_fp2,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_is_square(a: *const bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sqrt_in_place(a: *mut bn254_snarks_fp2);
}
extern "C" {
    pub fn ctt_bn254_snarks_fp2_sqrt_if_square_in_place(a: *mut bn254_snarks_fp2) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_eq(
        P: *const bn254_snarks_g1_aff,
        Q: *const bn254_snarks_g1_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_inf(P: *const bn254_snarks_g1_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_set_inf(P: *mut bn254_snarks_g1_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_ccopy(
        P: *mut bn254_snarks_g1_aff,
        Q: *const bn254_snarks_g1_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_is_on_curve(
        x: *const bn254_snarks_fp,
        y: *const bn254_snarks_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_neg(P: *mut bn254_snarks_g1_aff, Q: *const bn254_snarks_g1_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_aff_neg_in_place(P: *mut bn254_snarks_g1_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_is_eq(
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_is_inf(P: *const bn254_snarks_g1_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_set_inf(P: *mut bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_ccopy(
        P: *mut bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_neg(P: *mut bn254_snarks_g1_jac, Q: *const bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_neg_in_place(P: *mut bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_cneg_in_place(P: *mut bn254_snarks_g1_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_sum(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_add_in_place(
        P: *mut bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_diff(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
        Q: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_double(
        r: *mut bn254_snarks_g1_jac,
        P: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_double_in_place(P: *mut bn254_snarks_g1_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_affine(
        dst: *mut bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_from_affine(
        dst: *mut bn254_snarks_g1_jac,
        src: *const bn254_snarks_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_is_eq(
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_is_inf(P: *const bn254_snarks_g1_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_set_inf(P: *mut bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_ccopy(
        P: *mut bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_neg(P: *mut bn254_snarks_g1_prj, Q: *const bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_neg_in_place(P: *mut bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_cneg_in_place(P: *mut bn254_snarks_g1_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_sum(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_add_in_place(
        P: *mut bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_diff(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
        Q: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_double(
        r: *mut bn254_snarks_g1_prj,
        P: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_double_in_place(P: *mut bn254_snarks_g1_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_affine(
        dst: *mut bn254_snarks_g1_aff,
        src: *const bn254_snarks_g1_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_from_affine(
        dst: *mut bn254_snarks_g1_prj,
        src: *const bn254_snarks_g1_aff,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_eq(
        P: *const bn254_snarks_g2_aff,
        Q: *const bn254_snarks_g2_aff,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_inf(P: *const bn254_snarks_g2_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_set_inf(P: *mut bn254_snarks_g2_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_ccopy(
        P: *mut bn254_snarks_g2_aff,
        Q: *const bn254_snarks_g2_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_is_on_curve(
        x: *const bn254_snarks_fp2,
        y: *const bn254_snarks_fp2,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_neg(P: *mut bn254_snarks_g2_aff, Q: *const bn254_snarks_g2_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_aff_neg_in_place(P: *mut bn254_snarks_g2_aff);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_is_eq(
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_is_inf(P: *const bn254_snarks_g2_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_set_inf(P: *mut bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_ccopy(
        P: *mut bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_neg(P: *mut bn254_snarks_g2_jac, Q: *const bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_neg_in_place(P: *mut bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_cneg_in_place(P: *mut bn254_snarks_g2_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_sum(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_add_in_place(
        P: *mut bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_diff(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
        Q: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_double(
        r: *mut bn254_snarks_g2_jac,
        P: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_double_in_place(P: *mut bn254_snarks_g2_jac);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_affine(
        dst: *mut bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_jac,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_jac_from_affine(
        dst: *mut bn254_snarks_g2_jac,
        src: *const bn254_snarks_g2_aff,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_is_eq(
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_is_inf(P: *const bn254_snarks_g2_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_set_inf(P: *mut bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_ccopy(
        P: *mut bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_neg(P: *mut bn254_snarks_g2_prj, Q: *const bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_neg_in_place(P: *mut bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_cneg_in_place(P: *mut bn254_snarks_g2_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_sum(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_add_in_place(
        P: *mut bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_diff(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
        Q: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_double(
        r: *mut bn254_snarks_g2_prj,
        P: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_double_in_place(P: *mut bn254_snarks_g2_prj);
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_affine(
        dst: *mut bn254_snarks_g2_aff,
        src: *const bn254_snarks_g2_prj,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g2_prj_from_affine(
        dst: *mut bn254_snarks_g2_prj,
        src: *const bn254_snarks_g2_aff,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_fr {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_pallas_fr() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_fr>(),
        32usize,
        concat!("Size of: ", stringify!(pallas_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_fr>(),
        8usize,
        concat!("Alignment of ", stringify!(pallas_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_fp {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_pallas_fp() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_fp>(),
        32usize,
        concat!("Size of: ", stringify!(pallas_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_fp>(),
        8usize,
        concat!("Alignment of ", stringify!(pallas_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_ec_aff {
    x: pallas_fp,
    y: pallas_fp,
}
#[test]
fn bindgen_test_layout_pallas_ec_aff() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_ec_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_ec_aff>(),
        64usize,
        concat!("Size of: ", stringify!(pallas_ec_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_ec_aff>(),
        8usize,
        concat!("Alignment of ", stringify!(pallas_ec_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_ec_jac {
    x: pallas_fp,
    y: pallas_fp,
    z: pallas_fp,
}
#[test]
fn bindgen_test_layout_pallas_ec_jac() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_ec_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_ec_jac>(),
        96usize,
        concat!("Size of: ", stringify!(pallas_ec_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_ec_jac>(),
        8usize,
        concat!("Alignment of ", stringify!(pallas_ec_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pallas_ec_prj {
    x: pallas_fp,
    y: pallas_fp,
    z: pallas_fp,
}
#[test]
fn bindgen_test_layout_pallas_ec_prj() {
    const UNINIT: ::core::mem::MaybeUninit<pallas_ec_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pallas_ec_prj>(),
        96usize,
        concat!("Size of: ", stringify!(pallas_ec_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<pallas_ec_prj>(),
        8usize,
        concat!("Alignment of ", stringify!(pallas_ec_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pallas_ec_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fr_unmarshalBE(dst: *mut pallas_fr, src: *const byte, src_len: isize)
        -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fr_marshalBE(dst: *mut byte, dst_len: isize, src: *const pallas_fr) -> bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_eq(a: *const pallas_fr, b: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_zero(a: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_one(a: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_is_minus_one(a: *const pallas_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fr_set_zero(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_set_one(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_set_minus_one(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_neg(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_neg_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_sum(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_add_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_diff(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_sub_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_double(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_double_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_prod(r: *mut pallas_fr, a: *const pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_mul_in_place(a: *mut pallas_fr, b: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_square(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_square_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_div2(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_inv(r: *mut pallas_fr, a: *const pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_inv_in_place(a: *mut pallas_fr);
}
extern "C" {
    pub fn ctt_pallas_fr_ccopy(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cswap(a: *mut pallas_fr, b: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cset_zero(a: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cset_one(a: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cneg_in_place(a: *mut pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_cadd_in_place(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fr_csub_in_place(a: *mut pallas_fr, b: *const pallas_fr, ctl: secret_bool);
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fp_unmarshalBE(dst: *mut pallas_fp, src: *const byte, src_len: isize)
        -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_pallas_fp_marshalBE(dst: *mut byte, dst_len: isize, src: *const pallas_fp) -> bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_eq(a: *const pallas_fp, b: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_zero(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_one(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_is_minus_one(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_set_zero(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_set_one(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_set_minus_one(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_neg(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_neg_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_sum(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_add_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_diff(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_sub_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_double(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_double_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_prod(r: *mut pallas_fp, a: *const pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_mul_in_place(a: *mut pallas_fp, b: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_square(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_square_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_div2(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_inv(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_inv_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_ccopy(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cswap(a: *mut pallas_fp, b: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cset_zero(a: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cset_one(a: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cneg_in_place(a: *mut pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_cadd_in_place(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_csub_in_place(a: *mut pallas_fp, b: *const pallas_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_fp_is_square(a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_invsqrt(r: *mut pallas_fp, a: *const pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_invsqrt_in_place(r: *mut pallas_fp, a: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_in_place(a: *mut pallas_fp);
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_if_square_in_place(a: *mut pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_invsqrt(
        sqrt: *mut pallas_fp,
        invsqrt: *mut pallas_fp,
        a: *const pallas_fp,
    );
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_invsqrt_if_square(
        sqrt: *mut pallas_fp,
        invsqrt: *mut pallas_fp,
        a: *const pallas_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_fp_sqrt_ratio_if_square(
        r: *mut pallas_fp,
        u: *const pallas_fp,
        v: *const pallas_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_is_eq(P: *const pallas_ec_aff, Q: *const pallas_ec_aff)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_is_inf(P: *const pallas_ec_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_set_inf(P: *mut pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_aff_ccopy(
        P: *mut pallas_ec_aff,
        Q: *const pallas_ec_aff,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_aff_is_on_curve(x: *const pallas_fp, y: *const pallas_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_aff_neg(P: *mut pallas_ec_aff, Q: *const pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_aff_neg_in_place(P: *mut pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_is_eq(P: *const pallas_ec_jac, Q: *const pallas_ec_jac)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_jac_is_inf(P: *const pallas_ec_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_jac_set_inf(P: *mut pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_ccopy(
        P: *mut pallas_ec_jac,
        Q: *const pallas_ec_jac,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_neg(P: *mut pallas_ec_jac, Q: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_neg_in_place(P: *mut pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_cneg_in_place(P: *mut pallas_ec_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_sum(
        r: *mut pallas_ec_jac,
        P: *const pallas_ec_jac,
        Q: *const pallas_ec_jac,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_add_in_place(P: *mut pallas_ec_jac, Q: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_diff(
        r: *mut pallas_ec_jac,
        P: *const pallas_ec_jac,
        Q: *const pallas_ec_jac,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_double(r: *mut pallas_ec_jac, P: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_double_in_place(P: *mut pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_affine(dst: *mut pallas_ec_aff, src: *const pallas_ec_jac);
}
extern "C" {
    pub fn ctt_pallas_ec_jac_from_affine(dst: *mut pallas_ec_jac, src: *const pallas_ec_aff);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_is_eq(P: *const pallas_ec_prj, Q: *const pallas_ec_prj)
        -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_prj_is_inf(P: *const pallas_ec_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_pallas_ec_prj_set_inf(P: *mut pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_ccopy(
        P: *mut pallas_ec_prj,
        Q: *const pallas_ec_prj,
        ctl: secret_bool,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_neg(P: *mut pallas_ec_prj, Q: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_neg_in_place(P: *mut pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_cneg_in_place(P: *mut pallas_ec_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_sum(
        r: *mut pallas_ec_prj,
        P: *const pallas_ec_prj,
        Q: *const pallas_ec_prj,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_add_in_place(P: *mut pallas_ec_prj, Q: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_diff(
        r: *mut pallas_ec_prj,
        P: *const pallas_ec_prj,
        Q: *const pallas_ec_prj,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_double(r: *mut pallas_ec_prj, P: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_double_in_place(P: *mut pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_affine(dst: *mut pallas_ec_aff, src: *const pallas_ec_prj);
}
extern "C" {
    pub fn ctt_pallas_ec_prj_from_affine(dst: *mut pallas_ec_prj, src: *const pallas_ec_aff);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_fr {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_vesta_fr() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_fr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_fr>(),
        32usize,
        concat!("Size of: ", stringify!(vesta_fr))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_fr>(),
        8usize,
        concat!("Alignment of ", stringify!(vesta_fr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_fr),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_fp {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_vesta_fp() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_fp>(),
        32usize,
        concat!("Size of: ", stringify!(vesta_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_fp>(),
        8usize,
        concat!("Alignment of ", stringify!(vesta_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_fp),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_ec_aff {
    x: vesta_fp,
    y: vesta_fp,
}
#[test]
fn bindgen_test_layout_vesta_ec_aff() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_ec_aff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_ec_aff>(),
        64usize,
        concat!("Size of: ", stringify!(vesta_ec_aff))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_ec_aff>(),
        8usize,
        concat!("Alignment of ", stringify!(vesta_ec_aff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_aff),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_aff),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_ec_jac {
    x: vesta_fp,
    y: vesta_fp,
    z: vesta_fp,
}
#[test]
fn bindgen_test_layout_vesta_ec_jac() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_ec_jac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_ec_jac>(),
        96usize,
        concat!("Size of: ", stringify!(vesta_ec_jac))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_ec_jac>(),
        8usize,
        concat!("Alignment of ", stringify!(vesta_ec_jac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_jac),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_jac),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_jac),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vesta_ec_prj {
    x: vesta_fp,
    y: vesta_fp,
    z: vesta_fp,
}
#[test]
fn bindgen_test_layout_vesta_ec_prj() {
    const UNINIT: ::core::mem::MaybeUninit<vesta_ec_prj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vesta_ec_prj>(),
        96usize,
        concat!("Size of: ", stringify!(vesta_ec_prj))
    );
    assert_eq!(
        ::core::mem::align_of::<vesta_ec_prj>(),
        8usize,
        concat!("Alignment of ", stringify!(vesta_ec_prj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_prj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_prj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vesta_ec_prj),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fr_unmarshalBE(dst: *mut vesta_fr, src: *const byte, src_len: isize) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fr_marshalBE(dst: *mut byte, dst_len: isize, src: *const vesta_fr) -> bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_eq(a: *const vesta_fr, b: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_zero(a: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_one(a: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_is_minus_one(a: *const vesta_fr) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fr_set_zero(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_set_one(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_set_minus_one(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_neg(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_neg_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_sum(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_add_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_diff(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_sub_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_double(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_double_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_prod(r: *mut vesta_fr, a: *const vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_mul_in_place(a: *mut vesta_fr, b: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_square(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_square_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_div2(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_inv(r: *mut vesta_fr, a: *const vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_inv_in_place(a: *mut vesta_fr);
}
extern "C" {
    pub fn ctt_vesta_fr_ccopy(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cswap(a: *mut vesta_fr, b: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cset_zero(a: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cset_one(a: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cneg_in_place(a: *mut vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_cadd_in_place(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fr_csub_in_place(a: *mut vesta_fr, b: *const vesta_fr, ctl: secret_bool);
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fp_unmarshalBE(dst: *mut vesta_fp, src: *const byte, src_len: isize) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_vesta_fp_marshalBE(dst: *mut byte, dst_len: isize, src: *const vesta_fp) -> bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_eq(a: *const vesta_fp, b: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_zero(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_one(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_is_minus_one(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_set_zero(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_set_one(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_set_minus_one(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_neg(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_neg_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_sum(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_add_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_diff(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_sub_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_double(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_double_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_prod(r: *mut vesta_fp, a: *const vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_mul_in_place(a: *mut vesta_fp, b: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_square(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_square_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_div2(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_inv(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_inv_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_ccopy(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cswap(a: *mut vesta_fp, b: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cset_zero(a: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cset_one(a: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cneg_in_place(a: *mut vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_cadd_in_place(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_csub_in_place(a: *mut vesta_fp, b: *const vesta_fp, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_fp_is_square(a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_invsqrt(r: *mut vesta_fp, a: *const vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_invsqrt_in_place(r: *mut vesta_fp, a: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_in_place(a: *mut vesta_fp);
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_if_square_in_place(a: *mut vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_invsqrt(
        sqrt: *mut vesta_fp,
        invsqrt: *mut vesta_fp,
        a: *const vesta_fp,
    );
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_invsqrt_if_square(
        sqrt: *mut vesta_fp,
        invsqrt: *mut vesta_fp,
        a: *const vesta_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_fp_sqrt_ratio_if_square(
        r: *mut vesta_fp,
        u: *const vesta_fp,
        v: *const vesta_fp,
    ) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_is_eq(P: *const vesta_ec_aff, Q: *const vesta_ec_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_is_inf(P: *const vesta_ec_aff) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_set_inf(P: *mut vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_aff_ccopy(P: *mut vesta_ec_aff, Q: *const vesta_ec_aff, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_aff_is_on_curve(x: *const vesta_fp, y: *const vesta_fp) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_aff_neg(P: *mut vesta_ec_aff, Q: *const vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_aff_neg_in_place(P: *mut vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_is_eq(P: *const vesta_ec_jac, Q: *const vesta_ec_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_jac_is_inf(P: *const vesta_ec_jac) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_jac_set_inf(P: *mut vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_ccopy(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_neg(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_neg_in_place(P: *mut vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_cneg_in_place(P: *mut vesta_ec_jac, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_sum(
        r: *mut vesta_ec_jac,
        P: *const vesta_ec_jac,
        Q: *const vesta_ec_jac,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_add_in_place(P: *mut vesta_ec_jac, Q: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_diff(
        r: *mut vesta_ec_jac,
        P: *const vesta_ec_jac,
        Q: *const vesta_ec_jac,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_double(r: *mut vesta_ec_jac, P: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_double_in_place(P: *mut vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_affine(dst: *mut vesta_ec_aff, src: *const vesta_ec_jac);
}
extern "C" {
    pub fn ctt_vesta_ec_jac_from_affine(dst: *mut vesta_ec_jac, src: *const vesta_ec_aff);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_is_eq(P: *const vesta_ec_prj, Q: *const vesta_ec_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_prj_is_inf(P: *const vesta_ec_prj) -> secret_bool;
}
extern "C" {
    pub fn ctt_vesta_ec_prj_set_inf(P: *mut vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_ccopy(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_neg(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_neg_in_place(P: *mut vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_cneg_in_place(P: *mut vesta_ec_prj, ctl: secret_bool);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_sum(
        r: *mut vesta_ec_prj,
        P: *const vesta_ec_prj,
        Q: *const vesta_ec_prj,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_add_in_place(P: *mut vesta_ec_prj, Q: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_diff(
        r: *mut vesta_ec_prj,
        P: *const vesta_ec_prj,
        Q: *const vesta_ec_prj,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_double(r: *mut vesta_ec_prj, P: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_double_in_place(P: *mut vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_affine(dst: *mut vesta_ec_aff, src: *const vesta_ec_prj);
}
extern "C" {
    pub fn ctt_vesta_ec_prj_from_affine(dst: *mut vesta_ec_prj, src: *const vesta_ec_aff);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct big255 {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_big255() {
    const UNINIT: ::core::mem::MaybeUninit<big255> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<big255>(),
        32usize,
        concat!("Size of: ", stringify!(big255))
    );
    assert_eq!(
        ::core::mem::align_of::<big255>(),
        8usize,
        concat!("Alignment of ", stringify!(big255))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(big255),
            "::",
            stringify!(limbs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct big254 {
    limbs: [secret_word; 4usize],
}
#[test]
fn bindgen_test_layout_big254() {
    const UNINIT: ::core::mem::MaybeUninit<big254> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<big254>(),
        32usize,
        concat!("Size of: ", stringify!(big254))
    );
    assert_eq!(
        ::core::mem::align_of::<big254>(),
        8usize,
        concat!("Alignment of ", stringify!(big254))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(big254),
            "::",
            stringify!(limbs)
        )
    );
}
extern "C" {
    #[must_use]
    #[doc = " Validate a scalar\n  Regarding timing attacks, this will leak information\n  if the scalar is 0 or larger than the curve order."]
    pub fn ctt_bls12_381_validate_scalar(scalar: *const big255) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate a G1 point\n  This is an expensive operation that can be cached"]
    pub fn ctt_bls12_381_validate_g1(point: *const bls12_381_g1_aff) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate a G2 point\n  This is an expensive operation that can be cached"]
    pub fn ctt_bls12_381_validate_g2(point: *const bls12_381_g2_aff) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a scalar\n  Returns cttCodecScalar_Success if successful"]
    pub fn ctt_bls12_381_serialize_scalar(
        dst: *mut byte,
        scalar: *const big255,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a scalar\n  Also validates the scalar range\n\n  This is protected against side-channel unless the scalar is invalid.\n  In that case it will leak whether it's all zeros or larger than the curve order.\n\n  This special-cases (and leaks) 0 scalar as this is a special-case in most protocols\n  or completely invalid (for secret keys)."]
    pub fn ctt_bls12_381_deserialize_scalar(
        dst: *mut big255,
        src: *const byte,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a BLS12-381 G1 point in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_bls12_381_serialize_g1_compressed(
        dst: *mut byte,
        src: *const bls12_381_g1_aff,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G1 point in compressed (Zcash) format.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks."]
    pub fn ctt_bls12_381_deserialize_g1_compressed_unchecked(
        dst: *mut bls12_381_g1_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G1 point in compressed (Zcash) format\n  This also validates the G1 point"]
    pub fn ctt_bls12_381_deserialize_g1_compressed(
        dst: *mut bls12_381_g1_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a BLS12-381 G2 point in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_bls12_381_serialize_g2_compressed(
        dst: *mut byte,
        src: *const bls12_381_g2_aff,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G2 point in compressed (Zcash) format.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks."]
    pub fn ctt_bls12_381_deserialize_g2_compressed_unchecked(
        dst: *mut bls12_381_g2_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a BLS12-381 G2 point in compressed (Zcash) format\n  This also validates the G2 point"]
    pub fn ctt_bls12_381_deserialize_g2_compressed(
        dst: *mut bls12_381_g2_aff,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_jac,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_jac,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_prj,
        coefs: *const big255,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bls12_381_g1_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bls12_381_g1_prj,
        coefs: *const bls12_381_fr,
        points: *const bls12_381_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_jac,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_jac,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_prj,
        coefs: *const big254,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_bn254_snarks_g1_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut bn254_snarks_g1_prj,
        coefs: *const bn254_snarks_fr,
        points: *const bn254_snarks_g1_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_jac,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_jac,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_prj,
        coefs: *const big255,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_pallas_ec_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut pallas_ec_prj,
        coefs: *const pallas_fr,
        points: *const pallas_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_jac,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_jac_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_jac,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_big_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_prj,
        coefs: *const big255,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
extern "C" {
    pub fn ctt_vesta_ec_prj_multi_scalar_mul_fr_coefs_vartime_parallel(
        tp: *const ctt_threadpool,
        r: *mut vesta_ec_prj,
        coefs: *const vesta_fr,
        points: *const vesta_ec_aff,
        len: usize,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_fp {
    raw: [byte; 48usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_fp() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_fp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_fp>(),
        48usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_fp))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_fp>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_fp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_fp),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_fp2 {
    coords: [ctt_eth_bls_fp; 2usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_fp2() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_fp2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_fp2>(),
        96usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_fp2))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_fp2>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_fp2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coords) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_fp2),
            "::",
            stringify!(coords)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_seckey {
    raw: [byte; 32usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_seckey() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_seckey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_seckey>(),
        32usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_seckey))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_seckey>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_seckey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_seckey),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_pubkey {
    x: ctt_eth_bls_fp,
    y: ctt_eth_bls_fp,
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_pubkey() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_pubkey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_pubkey>(),
        96usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_pubkey))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_pubkey>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_pubkey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_pubkey),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_pubkey),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_bls_signature {
    x: ctt_eth_bls_fp2,
    y: ctt_eth_bls_fp2,
}
#[test]
fn bindgen_test_layout_ctt_eth_bls_signature() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_bls_signature> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_bls_signature>(),
        192usize,
        concat!("Size of: ", stringify!(ctt_eth_bls_signature))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_bls_signature>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_bls_signature))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_signature),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_bls_signature),
            "::",
            stringify!(y)
        )
    );
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_bls_status {
    cttEthBls_Success = 0,
    cttEthBls_VerificationFailure = 1,
    cttEthBls_InputsLengthsMismatch = 2,
    cttEthBls_ZeroLengthAggregation = 3,
    cttEthBls_PointAtInfinity = 4,
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_pubkey_is_zero(pubkey: *const ctt_eth_bls_pubkey) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_signature_is_zero(sig: *const ctt_eth_bls_signature) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_pubkeys_are_equal(
        a: *const ctt_eth_bls_pubkey,
        b: *const ctt_eth_bls_pubkey,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn ctt_eth_bls_signatures_are_equal(
        a: *const ctt_eth_bls_signature,
        b: *const ctt_eth_bls_signature,
    ) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = " Validate the secret key.\n\n  Regarding timing attacks, this will leak timing information only if the key is invalid.\n  Namely, the secret key is 0 or the secret key is too large."]
    pub fn ctt_eth_bls_validate_seckey(
        seckey: *const ctt_eth_bls_seckey,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate the public key.\n\n  This is an expensive operation that can be cached."]
    pub fn ctt_eth_bls_validate_pubkey(pubkey: *const ctt_eth_bls_pubkey) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Validate the signature.\n\n  This is an expensive operation that can be cached."]
    pub fn ctt_eth_bls_validate_signature(
        pubkey: *const ctt_eth_bls_signature,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a secret key\n\n  Returns cttCodecScalar_Success if successful"]
    pub fn ctt_eth_bls_serialize_seckey(
        dst: *mut byte,
        seckey: *const ctt_eth_bls_seckey,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a public key in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_serialize_pubkey_compressed(
        dst: *mut byte,
        pubkey: *const ctt_eth_bls_pubkey,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Serialize a signature in compressed (Zcash) format\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_serialize_signature_compressed(
        dst: *mut byte,
        sig: *const ctt_eth_bls_signature,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a secret key\n  This also validates the secret key.\n\n  This is protected against side-channel unless your key is invalid.\n  In that case it will like whether it's all zeros or larger than the curve order."]
    pub fn ctt_eth_bls_deserialize_seckey(
        seckey: *mut ctt_eth_bls_seckey,
        src: *const byte,
    ) -> ctt_codec_scalar_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a public key in compressed (Zcash) format.\n  This does not validate the public key.\n  It is intended for cases where public keys are stored in a trusted location\n  and validation can be cached.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_pubkey_compressed_unchecked(
        pubkey: *mut ctt_eth_bls_pubkey,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a public_key in compressed (Zcash) format.\n  This also validates the public key.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_pubkey_compressed(
        pubkey: *mut ctt_eth_bls_pubkey,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a signature in compressed (Zcash) format.\n  This does not validate the signature.\n  It is intended for cases where public keys are stored in a trusted location\n  and validation can be cached.\n\n  Warning :\n    This procedure skips the very expensive subgroup checks.\n    Not checking subgroup exposes a protocol to small subgroup attacks.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_signature_compressed_unchecked(
        sig: *mut ctt_eth_bls_signature,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[must_use]
    #[doc = " Deserialize a signature in compressed (Zcash) format.\n  This also validates the signature.\n\n  Returns cttCodecEcc_Success if successful"]
    pub fn ctt_eth_bls_deserialize_signature_compressed(
        sig: *mut ctt_eth_bls_signature,
        src: *const byte,
    ) -> ctt_codec_ecc_status;
}
extern "C" {
    #[doc = " Derive the public key matching with a secret key\n\n  Secret protection:\n  - A valid secret key will only leak that it is valid.\n  - An invalid secret key will leak whether it's all zero or larger than the curve order."]
    pub fn ctt_eth_bls_derive_pubkey(
        pubkey: *mut ctt_eth_bls_pubkey,
        seckey: *const ctt_eth_bls_seckey,
    );
}
extern "C" {
    #[doc = " Produce a signature for the message under the specified secret key\n  Signature is on BLS12-381 G2 (and public key on G1)\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - A secret key\n  - A message\n\n  Output:\n  - `signature` is overwritten with `message` signed with `secretKey`\n    with the scheme\n  - A status code indicating success or if the secret key is invalid.\n\n  Secret protection:\n  - A valid secret key will only leak that it is valid.\n  - An invalid secret key will leak whether it's all zero or larger than the curve order."]
    pub fn ctt_eth_bls_sign(
        sig: *mut ctt_eth_bls_signature,
        seckey: *const ctt_eth_bls_seckey,
        message: *const byte,
        message_len: isize,
    );
}
extern "C" {
    #[must_use]
    #[doc = " Check that a signature is valid for a message\n  under the provided public key.\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - A public key initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - A message\n  - A signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  Output:\n  - a status code with verification success if signature is valid\n    or indicating verification failure\n\n  In particular, the public key and signature are assumed to be on curve and subgroup-checked."]
    pub fn ctt_eth_bls_verify(
        pubkey: *const ctt_eth_bls_pubkey,
        message: *const byte,
        message_len: isize,
        sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
extern "C" {
    #[must_use]
    #[doc = " Check that a signature is valid for a message\n  under the aggregate of provided public keys.\n  returns `true` if the signature is valid, `false` otherwise.\n\n  For message domain separation purpose, the tag is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`\n\n  Input:\n  - Public keys initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_pubkey\n  - A message\n  - A signature initialized by one of the key derivation or deserialization procedure.\n    Or validated via validate_signature\n\n  In particular, the public keys and signature are assumed to be on curve subgroup checked."]
    pub fn ctt_eth_bls_fast_aggregate_verify(
        pubkeys: *const ctt_eth_bls_pubkey,
        pubkeys_len: isize,
        message: *const byte,
        message_len: isize,
        aggregate_sig: *const ctt_eth_bls_signature,
    ) -> ctt_eth_bls_status;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_context_struct {
    _unused: [u8; 0],
}
pub type ctt_eth_kzg_context = ctt_eth_kzg_context_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_commitment {
    raw: [byte; 48usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_commitment() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_commitment> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_commitment>(),
        48usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_commitment))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_commitment>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_commitment))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_commitment),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_proof {
    raw: [byte; 48usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_proof() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_proof> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_proof>(),
        48usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_proof))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_proof>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_proof))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_proof),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_blob {
    raw: [byte; 131072usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_blob() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_blob> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_blob>(),
        131072usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_blob))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_blob>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_blob))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_blob),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_opening_challenge {
    raw: [byte; 32usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_opening_challenge() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_opening_challenge> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_opening_challenge>(),
        32usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_opening_challenge))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_opening_challenge>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_opening_challenge))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_opening_challenge),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctt_eth_kzg_eval_at_challenge {
    raw: [byte; 32usize],
}
#[test]
fn bindgen_test_layout_ctt_eth_kzg_eval_at_challenge() {
    const UNINIT: ::core::mem::MaybeUninit<ctt_eth_kzg_eval_at_challenge> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctt_eth_kzg_eval_at_challenge>(),
        32usize,
        concat!("Size of: ", stringify!(ctt_eth_kzg_eval_at_challenge))
    );
    assert_eq!(
        ::core::mem::align_of::<ctt_eth_kzg_eval_at_challenge>(),
        1usize,
        concat!("Alignment of ", stringify!(ctt_eth_kzg_eval_at_challenge))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctt_eth_kzg_eval_at_challenge),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_kzg_status {
    cttEthKzg_Success = 0,
    cttEthKzg_VerificationFailure = 1,
    cttEthKzg_InputsLengthsMismatch = 2,
    cttEthKzg_ScalarZero = 3,
    cttEthKzg_ScalarLargerThanCurveOrder = 4,
    cttEthKzg_EccInvalidEncoding = 5,
    cttEthKzg_EccCoordinateGreaterThanOrEqualModulus = 6,
    cttEthKzg_EccPointNotOnCurve = 7,
    cttEthKzg_EccPointNotInSubgroup = 8,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_trusted_setup_status {
    cttEthTS_Success = 0,
    cttEthTS_MissingOrInaccessibleFile = 1,
    cttEthTS_InvalidFile = 2,
}
#[repr(u8)]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub enum ctt_eth_trusted_setup_format {
    cttEthTSFormat_ckzg4844 = 0,
}
extern "C" {
    #[must_use]
    #[doc = " Compute a commitment to the `blob`.\n  The commitment can be verified without needing the full `blob`\n\n  Mathematical description\n    commitment = [p()]\n\n    The blob data is used as a polynomial,\n    the polynomial is evaluated at powers of tau , a trusted setup.\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification challenge z.\n\n    with proof = [(p() - p(z)) / (-z)]"]
    pub fn ctt_eth_kzg_blob_to_kzg_commitment(
        ctx: *const ctt_eth_kzg_context,
        dst: *mut ctt_eth_kzg_commitment,
        blob: *const ctt_eth_kzg_blob,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Generate:\n  - A proof of correct evaluation.\n  - y = p(z), the evaluation of p at the challenge z, with p being the Blob interpreted as a polynomial.\n\n  Mathematical description\n    [proof] = [(p() - p(z)) / (-z)], with p() being the commitment, i.e. the evaluation of p at the powers of \n    The notation [a] corresponds to the scalar multiplication of a by the generator of 1\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification challenge z."]
    pub fn ctt_eth_kzg_compute_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        y: *mut ctt_eth_kzg_eval_at_challenge,
        blob: *const ctt_eth_kzg_blob,
        z: *const ctt_eth_kzg_opening_challenge,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify KZG proof\n  that p(z) == y where\n    - z is a random challenge\n    - y is the evaluation of the \"KZG polynomial\" p at z\n    - commitment is p(), the evaluation of p at the trusted setup ,\n    - [proof] = [(p() - p(z)) / (-z)], ensure that p(z) evaluation was correct\n      without needing access to the polynomial p itself."]
    pub fn ctt_eth_kzg_verify_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        commitment: *const ctt_eth_kzg_commitment,
        z: *const ctt_eth_kzg_opening_challenge,
        y: *const ctt_eth_kzg_eval_at_challenge,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob, return the KZG proof that is used to verify it against the commitment.\n  This method does not verify that the commitment is correct with respect to `blob`."]
    pub fn ctt_eth_kzg_compute_blob_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        proof: *mut ctt_eth_kzg_proof,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob and a KZG proof, verify that the blob data corresponds to the provided commitment."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof(
        ctx: *const ctt_eth_kzg_context,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify `n` (blob, commitment, proof) sets efficiently\n\n  `n` is the number of verifications set\n  - if n is negative, this procedure returns verification failure\n  - if n is zero, this procedure returns verification success\n\n  `secure_random_bytes` random bytes must come from a cryptographically secure RNG\n  or computed through the Fiat-Shamir heuristic.\n  It serves as a random number\n  that is not in the control of a potential attacker to prevent potential\n  rogue commitments attacks due to homomorphic properties of pairings,\n  i.e. commitments that are linear combination of others and sum would be zero."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_batch(
        ctx: *const ctt_eth_kzg_context,
        blobs: *const ctt_eth_kzg_blob,
        commitments: *const ctt_eth_kzg_commitment,
        proofs: *const ctt_eth_kzg_proof,
        n: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Load trusted setup from path\n  Currently the only format supported `cttEthTSFormat_ckzg4844`\n  is from the reference implementation c-kzg-4844 text file"]
    pub fn ctt_eth_trusted_setup_load(
        ctx: *mut *mut ctt_eth_kzg_context,
        filepath: *const ::core::ffi::c_char,
        format: ctt_eth_trusted_setup_format,
    ) -> ctt_eth_trusted_setup_status;
}
extern "C" {
    #[doc = " Destroy a trusted setup"]
    pub fn ctt_eth_trusted_setup_delete(ctx: *mut ctt_eth_kzg_context);
}
extern "C" {
    #[must_use]
    #[doc = " Compute a commitment to the `blob`.\n  The commitment can be verified without needing the full `blob`\n\n  Mathematical description\n    commitment = [p()]\n\n    The blob data is used as a polynomial,\n    the polynomial is evaluated at powers of tau , a trusted setup.\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification challenge z.\n\n    with proof = [(p() - p(z)) / (-z)]"]
    pub fn ctt_eth_kzg_blob_to_kzg_commitment_parallel(
        ctx: *const ctt_eth_kzg_context,
        tp: *const ctt_threadpool,
        dst: *mut ctt_eth_kzg_commitment,
        blob: *const ctt_eth_kzg_blob,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Generate:\n  - A proof of correct evaluation.\n  - y = p(z), the evaluation of p at the challenge z, with p being the Blob interpreted as a polynomial.\n\n  Mathematical description\n    [proof] = [(p() - p(z)) / (-z)], with p() being the commitment, i.e. the evaluation of p at the powers of \n    The notation [a] corresponds to the scalar multiplication of a by the generator of 1\n\n    Verification can be done by verifying the relation:\n      proof.( - z) = p()-p(z)\n    which doesn't require the full blob but only evaluations of it\n    - at , p() is the commitment\n    - and at the verification challenge z."]
    pub fn ctt_eth_kzg_compute_kzg_proof_parallel(
        ctx: *const ctt_eth_kzg_context,
        tp: *const ctt_threadpool,
        proof: *mut ctt_eth_kzg_proof,
        y: *mut ctt_eth_kzg_eval_at_challenge,
        blob: *const ctt_eth_kzg_blob,
        z: *const ctt_eth_kzg_opening_challenge,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob, return the KZG proof that is used to verify it against the commitment.\n  This method does not verify that the commitment is correct with respect to `blob`."]
    pub fn ctt_eth_kzg_compute_blob_kzg_proof_parallel(
        ctx: *const ctt_eth_kzg_context,
        tp: *const ctt_threadpool,
        proof: *mut ctt_eth_kzg_proof,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Given a blob and a KZG proof, verify that the blob data corresponds to the provided commitment."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_parallel(
        ctx: *const ctt_eth_kzg_context,
        tp: *const ctt_threadpool,
        blob: *const ctt_eth_kzg_blob,
        commitment: *const ctt_eth_kzg_commitment,
        proof: *const ctt_eth_kzg_proof,
    ) -> ctt_eth_kzg_status;
}
extern "C" {
    #[must_use]
    #[doc = " Verify `n` (blob, commitment, proof) sets efficiently\n\n  `n` is the number of verifications set\n  - if n is negative, this procedure returns verification failure\n  - if n is zero, this procedure returns verification success\n\n  `secure_random_bytes` random bytes must come from a cryptographically secure RNG\n  or computed through the Fiat-Shamir heuristic.\n  It serves as a random number\n  that is not in the control of a potential attacker to prevent potential\n  rogue commitments attacks due to homomorphic properties of pairings,\n  i.e. commitments that are linear combination of others and sum would be zero."]
    pub fn ctt_eth_kzg_verify_blob_kzg_proof_batch_parallel(
        ctx: *const ctt_eth_kzg_context,
        tp: *const ctt_threadpool,
        blobs: *const ctt_eth_kzg_blob,
        commitments: *const ctt_eth_kzg_commitment,
        proofs: *const ctt_eth_kzg_proof,
        n: usize,
        secure_random_bytes: *const byte,
    ) -> ctt_eth_kzg_status;
}
